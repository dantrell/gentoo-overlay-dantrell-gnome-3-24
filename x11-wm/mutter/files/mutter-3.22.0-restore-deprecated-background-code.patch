diff '--exclude=.git' -urN a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am	2016-09-16 10:24:13.000000000 -0400
+++ b/src/Makefile.am	2016-09-27 23:33:00.708843001 -0400
@@ -152,10 +152,8 @@
 	compositor/compositor.c			\
 	compositor/compositor-private.h		\
 	compositor/meta-background.c		\
-	compositor/meta-background-private.h	\
 	compositor/meta-background-actor.c	\
 	compositor/meta-background-actor-private.h	\
-	compositor/meta-background-image.c	\
 	compositor/meta-background-group.c	\
 	compositor/meta-cullable.c		\
 	compositor/meta-cullable.h		\
@@ -191,7 +189,6 @@
 	meta/compositor.h			\
 	meta/meta-background.h			\
 	meta/meta-background-actor.h		\
-	meta/meta-background-image.h		\
 	meta/meta-background-group.h		\
 	meta/meta-plugin.h			\
 	meta/meta-shadow-factory.h		\
@@ -406,10 +403,9 @@
 	meta/keybindings.h			\
 	meta/main.h				\
 	meta/meta-backend.h			\
-	meta/meta-background.h			\
 	meta/meta-background-actor.h		\
-	meta/meta-background-image.h		\
 	meta/meta-background-group.h		\
+	meta/meta-background.h			\
 	meta/meta-cursor-tracker.h		\
 	meta/meta-idle-monitor.h		\
 	meta/meta-plugin.h			\
diff '--exclude=.git' -urN a/src/compositor/cogl-utils.c b/src/compositor/cogl-utils.c
--- a/src/compositor/cogl-utils.c	2016-07-29 00:51:39.000000000 -0400
+++ b/src/compositor/cogl-utils.c	2016-09-27 23:33:00.708843001 -0400
@@ -64,78 +64,3 @@
 
   return pipeline;
 }
-
-static gboolean is_pot(int x)
-{
-  return x > 0 && (x & (x - 1)) == 0;
-}
-
-/**
- * meta_create_texture:
- * @width: width of the texture to create
- * @height: height of the texture to create
- * @components; components to store in the texture (color or alpha)
- * @flags: flags that affect the allocation behavior
- *
- * Creates a texture of the given size with the specified components
- * for use as a frame buffer object.
- *
- * If non-power-of-two textures are not supported on the system, then
- * the texture will be created as a texture rectangle; in this case,
- * hardware repeating isn't possible, and texture coordinates are also
- * different, but Cogl hides these issues from the application, except from
- * GLSL shaders. Since GLSL is never (or at least almost never)
- * present on such a system, this is not typically an issue.
- *
- * If %META_TEXTURE_ALLOW_SLICING is present in @flags, and the texture
- * is larger than the texture size limits of the system, then the texture
- * will be created as a sliced texture. This also will cause problems
- * with using the texture with GLSL, and is more likely to be an issue
- * since all GL implementations have texture size limits, and they can
- * be as small as 2048x2048 on reasonably current systems.
- */
-CoglTexture *
-meta_create_texture (int                   width,
-                     int                   height,
-                     CoglTextureComponents components,
-                     MetaTextureFlags      flags)
-{
-  ClutterBackend *backend = clutter_get_default_backend ();
-  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
-  CoglTexture *texture;
-
-  gboolean should_use_rectangle = FALSE;
-
-  if (!(is_pot (width) && is_pot (height)) &&
-      !cogl_has_feature (ctx, COGL_FEATURE_ID_TEXTURE_NPOT))
-    {
-      if (cogl_has_feature (ctx, COGL_FEATURE_ID_TEXTURE_RECTANGLE))
-        should_use_rectangle = TRUE;
-      else
-        g_error ("Cannot create texture. Support for GL_ARB_texture_non_power_of_two or "
-                 "ARB_texture_rectangle is required");
-    }
-
-  if (should_use_rectangle)
-    texture = COGL_TEXTURE (cogl_texture_rectangle_new_with_size (ctx, width, height));
-  else
-    texture = COGL_TEXTURE (cogl_texture_2d_new_with_size (ctx, width, height));
-  cogl_texture_set_components (texture, components);
-
-  if ((flags & META_TEXTURE_ALLOW_SLICING) != 0)
-    {
-      /* To find out if we need to slice the texture, we have to go ahead and force storage
-       * to be allocated
-       */
-      CoglError *catch_error = NULL;
-      if (!cogl_texture_allocate (texture, &catch_error))
-        {
-          cogl_error_free (catch_error);
-          cogl_object_unref (texture);
-          texture = COGL_TEXTURE (cogl_texture_2d_sliced_new_with_size (ctx, width, height, COGL_TEXTURE_MAX_WASTE));
-          cogl_texture_set_components (texture, components);
-        }
-    }
-
-  return texture;
-}
diff '--exclude=.git' -urN a/src/compositor/cogl-utils.h b/src/compositor/cogl-utils.h
--- a/src/compositor/cogl-utils.h	2016-07-29 00:51:39.000000000 -0400
+++ b/src/compositor/cogl-utils.h	2016-09-27 23:33:00.709842996 -0400
@@ -25,14 +25,4 @@
 
 CoglPipeline * meta_create_texture_pipeline (CoglTexture *texture);
 
-typedef enum {
-  META_TEXTURE_FLAGS_NONE = 0,
-  META_TEXTURE_ALLOW_SLICING = 1 << 1
-} MetaTextureFlags;
-
-CoglTexture *meta_create_texture (int                   width,
-                                  int                   height,
-                                  CoglTextureComponents components,
-                                  MetaTextureFlags      flags);
-
 #endif /* __META_COGL_UTILS_H__ */
diff '--exclude=.git' -urN a/src/compositor/meta-background-actor.c b/src/compositor/meta-background-actor.c
--- a/src/compositor/meta-background-actor.c	2016-07-29 00:51:39.000000000 -0400
+++ b/src/compositor/meta-background-actor.c	2016-09-27 23:33:00.709842996 -0400
@@ -1,7 +1,7 @@
 /* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
 /*
  * Copyright 2009 Sander Dijkhuis
- * Copyright 2014 Red Hat, Inc.
+ * Copyright 2010 Red Hat, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -26,122 +26,23 @@
  *
  */
 
-/*
- * The overall model drawing model of this widget is that we have one
- * texture, or two interpolated textures, possibly with alpha or
- * margins that let the underlying background show through, blended
- * over a solid color or a gradient. The result of that combination
- * can then be affected by a "vignette" that darkens the background
- * away from a central point (or as a no-GLSL fallback, simply darkens
- * the background) and by overall opacity.
- *
- * As of GNOME 3.14, GNOME is only using a fraction of this when the
- * user sets the background through the control center - what can be
- * set is:
- *
- *  A single image without a border
- *  An animation of images without a border that blend together,
- *   with the blend changing every 4-5 minutes
- *  A solid color with a repeated noise texture blended over it
- *
- * This all is pretty easy to do in a fragment shader, except when:
- *
- *  A) We don't have GLSL - in this case, the operation of
- *     interpolating the two textures and blending the result over the
- *     background can't be expressed with Cogl's fixed-function layer
- *     combining (which is confined to what GL's texture environment
- *     combining can do) So we can only handle the above directly if
- *     there are no margins or alpha.
- *
- *  B) The image textures are sliced. Texture size limits on older
- *     hardware (pre-965 intel hardware, r300, etc.)  is often 2048,
- *     and it would be common to use a texture larger than this for a
- *     background and expect it to be scaled down. Cogl can compensate
- *     for this by breaking the texture up into multiple textures, but
- *     can't multitexture with sliced textures. So we can only handle
- *     the above if there's a single texture.
- *
- * However, even when we *can* represent everything in a single pass,
- * it's not necessarily efficient. If we want to draw a 1024x768
- * background, it's pretty inefficient to bilinearly texture from
- * two 2560x1440 images and mix that. So the drawing model we take
- * here is that MetaBackground generates a single texture (which
- * might be a 1x1 texture for a solid color, or a 1x2 texture for a
- * gradient, or a repeated texture for wallpaper, or a pre-rendered
- * texture the size of the screen), and we draw with that, possibly
- * adding the vignette and opacity.
- */
-
 #include <config.h>
 
+#include <cogl/winsys/cogl-texture-pixmap-x11.h>
+
 #include <clutter/clutter.h>
 
+#include <X11/Xatom.h>
+
 #include "cogl-utils.h"
-#include "clutter-utils.h"
+#include "compositor-private.h"
 #include <meta/errors.h>
+#include <meta/meta-background.h>
 #include "meta-background-actor-private.h"
-#include "meta-background-private.h"
 #include "meta-cullable.h"
 
-enum
-{
-  PROP_META_SCREEN = 1,
-  PROP_MONITOR,
-  PROP_BACKGROUND,
-  PROP_VIGNETTE,
-  PROP_VIGNETTE_SHARPNESS,
-  PROP_BRIGHTNESS
-};
-
-typedef enum {
-  CHANGED_BACKGROUND = 1 << 0,
-  CHANGED_EFFECTS = 1 << 2,
-  CHANGED_VIGNETTE_PARAMETERS = 1 << 3,
-  CHANGED_ALL = 0xFFFF
-} ChangedFlags;
-
-#define VERTEX_SHADER_DECLARATIONS                                      \
-"uniform vec2 scale;\n"                                                 \
-"uniform vec2 offset;\n"                                                \
-"varying vec2 position;\n"                                              \
-
-#define VERTEX_SHADER_CODE                                              \
-"position = cogl_tex_coord0_in.xy * scale + offset;\n"                  \
-
-#define FRAGMENT_SHADER_DECLARATIONS                                    \
-"uniform float vignette_sharpness;\n"                                   \
-"varying vec2 position;\n"                                              \
-
-#define FRAGMENT_SHADER_CODE                                                   \
-"float t = 2.0 * length(position);\n"                                          \
-"t = min(t, 1.0);\n"                                                           \
-"float pixel_brightness = 1.0 - t * vignette_sharpness;\n"                       \
-"cogl_color_out.rgb = cogl_color_out.rgb * pixel_brightness;\n"                \
-
-typedef struct _MetaBackgroundLayer MetaBackgroundLayer;
-
-typedef enum {
-  PIPELINE_VIGNETTE = (1 << 0),
-  PIPELINE_BLEND = (1 << 1),
-} PipelineFlags;
-
 struct _MetaBackgroundActorPrivate
 {
-  MetaScreen *screen;
-  int monitor;
-
-  MetaBackground *background;
-
-  gboolean vignette;
-  double brightness;
-  double vignette_sharpness;
-
-  ChangedFlags changed;
-  CoglPipeline *pipeline;
-  PipelineFlags pipeline_flags;
-  cairo_rectangle_int_t texture_area;
-  gboolean force_bilinear;
-
   cairo_region_t *clip_region;
 };
 
@@ -165,45 +66,27 @@
 meta_background_actor_dispose (GObject *object)
 {
   MetaBackgroundActor *self = META_BACKGROUND_ACTOR (object);
-  MetaBackgroundActorPrivate *priv = self->priv;
 
   set_clip_region (self, NULL);
-  meta_background_actor_set_background (self, NULL);
-  if (priv->pipeline)
-    {
-      cogl_object_unref (priv->pipeline);
-      priv->pipeline = NULL;
-    }
 
   G_OBJECT_CLASS (meta_background_actor_parent_class)->dispose (object);
 }
 
 static void
-get_preferred_size (MetaBackgroundActor *self,
-                    gfloat              *width,
-                    gfloat              *height)
-{
-  MetaBackgroundActorPrivate *priv = META_BACKGROUND_ACTOR (self)->priv;
-  MetaRectangle monitor_geometry;
-
-  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
-
-  if (width != NULL)
-    *width = monitor_geometry.width;
-
-  if (height != NULL)
-    *height = monitor_geometry.height;
-}
-
-static void
 meta_background_actor_get_preferred_width (ClutterActor *actor,
                                            gfloat        for_height,
                                            gfloat       *min_width_p,
                                            gfloat       *natural_width_p)
 {
+  ClutterContent *content;
   gfloat width;
 
-  get_preferred_size (META_BACKGROUND_ACTOR (actor), &width, NULL);
+  content = clutter_actor_get_content (actor);
+
+  if (content)
+    clutter_content_get_preferred_size (content, &width, NULL);
+  else
+    width = 0;
 
   if (min_width_p)
     *min_width_p = width;
@@ -218,9 +101,15 @@
                                             gfloat       *natural_height_p)
 
 {
+  ClutterContent *content;
   gfloat height;
 
-  get_preferred_size (META_BACKGROUND_ACTOR (actor), NULL, &height);
+  content = clutter_actor_get_content (actor);
+
+  if (content)
+    clutter_content_get_preferred_size (content, NULL, &height);
+  else
+    height = 0;
 
   if (min_height_p)
     *min_height_p = height;
@@ -228,430 +117,43 @@
     *natural_height_p = height;
 }
 
-static CoglPipeline *
-make_pipeline (PipelineFlags pipeline_flags)
-{
-  static CoglPipeline *templates[4];
-  CoglPipeline **templatep;
-
-  templatep = &templates[pipeline_flags];
-  if (*templatep == NULL)
-    {
-      /* Cogl automatically caches pipelines with no eviction policy,
-       * so we need to prevent identical pipelines from getting cached
-       * separately, by reusing the same shader snippets.
-       */
-      *templatep = COGL_PIPELINE (meta_create_texture_pipeline (NULL));
-
-      if ((pipeline_flags & PIPELINE_VIGNETTE) != 0)
-        {
-          static CoglSnippet *vertex_snippet;
-          static CoglSnippet *fragment_snippet;
-
-          if (!vertex_snippet)
-            vertex_snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_VERTEX,
-                                               VERTEX_SHADER_DECLARATIONS, VERTEX_SHADER_CODE);
-
-          cogl_pipeline_add_snippet (*templatep, vertex_snippet);
-
-          if (!fragment_snippet)
-            fragment_snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT,
-                                                 FRAGMENT_SHADER_DECLARATIONS, FRAGMENT_SHADER_CODE);
-
-          cogl_pipeline_add_snippet (*templatep, fragment_snippet);
-        }
-
-      if ((pipeline_flags & PIPELINE_BLEND) == 0)
-        cogl_pipeline_set_blend (*templatep, "RGBA = ADD (SRC_COLOR, 0)", NULL);
-    }
-
-  return cogl_pipeline_copy (*templatep);
-}
-
-static void
-setup_pipeline (MetaBackgroundActor   *self,
-                cairo_rectangle_int_t *actor_pixel_rect)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-  PipelineFlags pipeline_flags = 0;
-  guint8 opacity;
-  float color_component;
-  CoglPipelineFilter filter;
-
-  opacity = clutter_actor_get_paint_opacity (CLUTTER_ACTOR (self));
-  if (opacity < 255)
-    pipeline_flags |= PIPELINE_BLEND;
-  if (priv->vignette && clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
-    pipeline_flags |= PIPELINE_VIGNETTE;
-
-  if (priv->pipeline &&
-      pipeline_flags != priv->pipeline_flags)
-    {
-      cogl_object_unref (priv->pipeline);
-      priv->pipeline = NULL;
-    }
-
-  if (priv->pipeline == NULL)
-    {
-      priv->pipeline_flags = pipeline_flags;
-      priv->pipeline = make_pipeline (pipeline_flags);
-      priv->changed = CHANGED_ALL;
-    }
-
-  if ((priv->changed & CHANGED_BACKGROUND) != 0)
-    {
-      CoglPipelineWrapMode wrap_mode;
-      CoglTexture *texture = meta_background_get_texture (priv->background,
-                                                          priv->monitor,
-                                                          &priv->texture_area,
-                                                          &wrap_mode);
-      priv->force_bilinear = texture &&
-        (priv->texture_area.width != (int)cogl_texture_get_width (texture) ||
-         priv->texture_area.height != (int)cogl_texture_get_height (texture));
-
-      cogl_pipeline_set_layer_texture (priv->pipeline, 0, texture);
-      cogl_pipeline_set_layer_wrap_mode (priv->pipeline, 0, wrap_mode);
-    }
-
-  if ((priv->changed & CHANGED_VIGNETTE_PARAMETERS) != 0)
-    {
-      cogl_pipeline_set_uniform_1f (priv->pipeline,
-                                    cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                        "vignette_sharpness"),
-                                    priv->vignette_sharpness);
-    }
-
-  if (priv->vignette)
-    {
-      color_component = priv->brightness * opacity / 255.;
-
-      if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
-        {
-          /* Darken everything to match the average brightness that would
-           * be there if we were drawing the vignette, which is
-           * (1 - (pi/12.) * vignette_sharpness) [exercise for the reader :]
-           */
-          color_component *= (1 - 0.74 * priv->vignette_sharpness);
-        }
-    }
-  else
-    color_component = opacity / 255.;
-
-  cogl_pipeline_set_color4f (priv->pipeline,
-                             color_component,
-                             color_component,
-                             color_component,
-                             opacity / 255.);
-
-  if (!priv->force_bilinear &&
-      meta_actor_painting_untransformed (actor_pixel_rect->width, actor_pixel_rect->height, NULL, NULL))
-    filter = COGL_PIPELINE_FILTER_NEAREST;
-  else
-    filter = COGL_PIPELINE_FILTER_LINEAR;
-
-  cogl_pipeline_set_layer_filters (priv->pipeline, 0, filter, filter);
-}
-
-static void
-set_glsl_parameters (MetaBackgroundActor   *self,
-                     cairo_rectangle_int_t *actor_pixel_rect)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-  float scale[2];
-  float offset[2];
-
-  /* Compute a scale and offset for transforming texture coordinates to the
-   * coordinate system from [-0.5 to 0.5] across the area of the actor
-   */
-  scale[0] = priv->texture_area.width / (float)actor_pixel_rect->width;
-  scale[1] = priv->texture_area.height / (float)actor_pixel_rect->height;
-  offset[0] = priv->texture_area.x / (float)actor_pixel_rect->width - 0.5;
-  offset[1] = priv->texture_area.y / (float)actor_pixel_rect->height - 0.5;
-
-  cogl_pipeline_set_uniform_float (priv->pipeline,
-                                   cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                       "scale"),
-                                   2, 1, scale);
-
-  cogl_pipeline_set_uniform_float (priv->pipeline,
-                                   cogl_pipeline_get_uniform_location (priv->pipeline,
-                                                                       "offset"),
-                                   2, 1, offset);
-}
-
-static void
-paint_clipped_rectangle (CoglFramebuffer       *fb,
-                         CoglPipeline          *pipeline,
-                         cairo_rectangle_int_t *rect,
-                         cairo_rectangle_int_t *texture_area)
-{
-  float x1, y1, x2, y2;
-  float tx1, ty1, tx2, ty2;
-
-  x1 = rect->x;
-  y1 = rect->y;
-  x2 = rect->x + rect->width;
-  y2 = rect->y + rect->height;
-
-  tx1 = (x1 - texture_area->x) / texture_area->width;
-  ty1 = (y1 - texture_area->y) / texture_area->height;
-  tx2 = (x2 - texture_area->x) / texture_area->width;
-  ty2 = (y2 - texture_area->y) / texture_area->height;
-
-  cogl_framebuffer_draw_textured_rectangle (fb, pipeline,
-                                            x1, y1, x2, y2,
-                                            tx1, ty1, tx2, ty2);
-}
-
-static gboolean
-meta_background_actor_get_paint_volume (ClutterActor       *actor,
-                                        ClutterPaintVolume *volume)
-{
-  return clutter_paint_volume_set_from_allocation (volume, actor);
-}
-
-static void
-meta_background_actor_paint (ClutterActor *actor)
-{
-  MetaBackgroundActor *self = META_BACKGROUND_ACTOR (actor);
-  MetaBackgroundActorPrivate *priv = self->priv;
-  ClutterActorBox actor_box;
-  cairo_rectangle_int_t actor_pixel_rect;
-  CoglFramebuffer *fb;
-  int i;
-
-  if ((priv->clip_region && cairo_region_is_empty (priv->clip_region)))
-    return;
-
-  clutter_actor_get_content_box (actor, &actor_box);
-  actor_pixel_rect.x = actor_box.x1;
-  actor_pixel_rect.y = actor_box.y1;
-  actor_pixel_rect.width = actor_box.x2 - actor_box.x1;
-  actor_pixel_rect.height = actor_box.y2 - actor_box.y1;
-
-  setup_pipeline (self, &actor_pixel_rect);
-  set_glsl_parameters (self, &actor_pixel_rect);
-
-  /* Limit to how many separate rectangles we'll draw; beyond this just
-   * fall back and draw the whole thing */
-#define MAX_RECTS 64
-
-  fb = cogl_get_draw_framebuffer ();
-
-  /* Now figure out what to actually paint.
-   */
-  if (priv->clip_region != NULL)
-    {
-      int n_rects = cairo_region_num_rectangles (priv->clip_region);
-      if (n_rects <= MAX_RECTS)
-        {
-           for (i = 0; i < n_rects; i++)
-             {
-               cairo_rectangle_int_t rect;
-               cairo_region_get_rectangle (priv->clip_region, i, &rect);
-
-               if (!gdk_rectangle_intersect (&actor_pixel_rect, &rect, &rect))
-                 continue;
-
-               paint_clipped_rectangle (fb, priv->pipeline, &rect, &priv->texture_area);
-             }
-
-           return;
-        }
-    }
-
-  paint_clipped_rectangle (fb, priv->pipeline, &actor_pixel_rect, &priv->texture_area);
-}
-
-static void
-meta_background_actor_set_property (GObject      *object,
-                                    guint         prop_id,
-                                    const GValue *value,
-                                    GParamSpec   *pspec)
-{
-  MetaBackgroundActor *self = META_BACKGROUND_ACTOR (object);
-  MetaBackgroundActorPrivate *priv = self->priv;
-
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      priv->screen = g_value_get_object (value);
-      break;
-    case PROP_MONITOR:
-      priv->monitor = g_value_get_int (value);
-      break;
-    case PROP_BACKGROUND:
-      meta_background_actor_set_background (self, g_value_get_object (value));
-      break;
-    case PROP_VIGNETTE:
-      meta_background_actor_set_vignette (self,
-                                          g_value_get_boolean (value),
-                                          priv->brightness,
-                                          priv->vignette_sharpness);
-      break;
-    case PROP_VIGNETTE_SHARPNESS:
-      meta_background_actor_set_vignette (self,
-                                          priv->vignette,
-                                          priv->brightness,
-                                          g_value_get_double (value));
-      break;
-    case PROP_BRIGHTNESS:
-      meta_background_actor_set_vignette (self,
-                                          priv->vignette,
-                                          g_value_get_double (value),
-                                          priv->vignette_sharpness);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
-static void
-meta_background_actor_get_property (GObject      *object,
-                                    guint         prop_id,
-                                    GValue       *value,
-                                    GParamSpec   *pspec)
-{
-  MetaBackgroundActorPrivate *priv = META_BACKGROUND_ACTOR (object)->priv;
-
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      g_value_set_object (value, priv->screen);
-      break;
-    case PROP_MONITOR:
-      g_value_set_int (value, priv->monitor);
-      break;
-    case PROP_BACKGROUND:
-      g_value_set_object (value, priv->background);
-      break;
-    case PROP_VIGNETTE:
-      g_value_set_boolean (value, priv->vignette);
-      break;
-    case PROP_BRIGHTNESS:
-      g_value_set_double (value, priv->brightness);
-      break;
-    case PROP_VIGNETTE_SHARPNESS:
-      g_value_set_double (value, priv->vignette_sharpness);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
-}
-
 static void
 meta_background_actor_class_init (MetaBackgroundActorClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
-  GParamSpec *param_spec;
 
   g_type_class_add_private (klass, sizeof (MetaBackgroundActorPrivate));
 
   object_class->dispose = meta_background_actor_dispose;
-  object_class->set_property = meta_background_actor_set_property;
-  object_class->get_property = meta_background_actor_get_property;
 
   actor_class->get_preferred_width = meta_background_actor_get_preferred_width;
   actor_class->get_preferred_height = meta_background_actor_get_preferred_height;
-  actor_class->get_paint_volume = meta_background_actor_get_paint_volume;
-  actor_class->paint = meta_background_actor_paint;
-
-  param_spec = g_param_spec_object ("meta-screen",
-                                    "MetaScreen",
-                                    "MetaScreen",
-                                    META_TYPE_SCREEN,
-                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_property (object_class,
-                                   PROP_META_SCREEN,
-                                   param_spec);
-
-  param_spec = g_param_spec_int ("monitor",
-                                 "monitor",
-                                 "monitor",
-                                 0, G_MAXINT, 0,
-                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_property (object_class,
-                                   PROP_MONITOR,
-                                   param_spec);
-
-  param_spec = g_param_spec_object ("background",
-                                    "Background",
-                                    "MetaBackground object holding background parameters",
-                                    META_TYPE_BACKGROUND,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_BACKGROUND,
-                                   param_spec);
-
-  param_spec = g_param_spec_boolean ("vignette",
-                                     "Vignette",
-                                     "Whether vignette effect is enabled",
-                                     FALSE,
-                                     G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_VIGNETTE,
-                                   param_spec);
-
-  param_spec = g_param_spec_double ("brightness",
-                                    "Brightness",
-                                    "Brightness of vignette effect",
-                                    0.0, 1.0, 1.0,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_BRIGHTNESS,
-                                   param_spec);
-
-  param_spec = g_param_spec_double ("vignette-sharpness",
-                                    "Vignette Sharpness",
-                                    "Sharpness of vignette effect",
-                                    0.0, G_MAXDOUBLE, 0.0,
-                                    G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_VIGNETTE_SHARPNESS,
-                                   param_spec);
 }
 
 static void
 meta_background_actor_init (MetaBackgroundActor *self)
 {
-  MetaBackgroundActorPrivate *priv;
-
-  priv = self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
-                                                   META_TYPE_BACKGROUND_ACTOR,
-                                                   MetaBackgroundActorPrivate);
-
-  priv->vignette = FALSE;
-  priv->brightness = 1.0;
-  priv->vignette_sharpness = 0.0;
+  self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+                                            META_TYPE_BACKGROUND_ACTOR,
+                                            MetaBackgroundActorPrivate);
 }
 
 /**
  * meta_background_actor_new:
- * @monitor: Index of the monitor for which to draw the background
  *
  * Creates a new actor to draw the background for the given monitor.
+ * This actor should be associated with a #MetaBackground using
+ * clutter_actor_set_content()
  *
  * Return value: the newly created background actor
  */
 ClutterActor *
-meta_background_actor_new (MetaScreen *screen,
-                           int         monitor)
+meta_background_actor_new (void)
 {
   MetaBackgroundActor *self;
 
-  self = g_object_new (META_TYPE_BACKGROUND_ACTOR,
-                       "meta-screen", screen,
-                       "monitor", monitor,
-                       NULL);
+  self = g_object_new (META_TYPE_BACKGROUND_ACTOR, NULL);
 
   return CLUTTER_ACTOR (self);
 }
@@ -693,90 +195,3 @@
   MetaBackgroundActorPrivate *priv = self->priv;
   return priv->clip_region;
 }
-
-static void
-invalidate_pipeline (MetaBackgroundActor *self,
-                     ChangedFlags         changed)
-{
-  MetaBackgroundActorPrivate *priv = self->priv;
-
-  priv->changed |= changed;
-}
-
-static void
-on_background_changed (MetaBackground      *background,
-                       MetaBackgroundActor *self)
-{
-  invalidate_pipeline (self, CHANGED_BACKGROUND);
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
-
-void
-meta_background_actor_set_background (MetaBackgroundActor *self,
-                                      MetaBackground      *background)
-{
-  MetaBackgroundActorPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND_ACTOR (self));
-  g_return_if_fail (background == NULL || META_IS_BACKGROUND (background));
-
-  priv = self->priv;
-
-  if (background == priv->background)
-    return;
-
-  if (priv->background)
-    {
-      g_signal_handlers_disconnect_by_func (priv->background,
-                                            (gpointer)on_background_changed,
-                                            self);
-      g_object_unref (priv->background);
-      priv->background = NULL;
-    }
-
-  if (background)
-    {
-      priv->background = g_object_ref (background);
-      g_signal_connect (priv->background, "changed",
-                        G_CALLBACK (on_background_changed), self);
-    }
-
-  invalidate_pipeline (self, CHANGED_BACKGROUND);
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
-
-void
-meta_background_actor_set_vignette (MetaBackgroundActor *self,
-                                    gboolean             enabled,
-                                    double               brightness,
-                                    double               sharpness)
-{
-  MetaBackgroundActorPrivate *priv;
-  gboolean changed = FALSE;
-
-  g_return_if_fail (META_IS_BACKGROUND_ACTOR (self));
-  g_return_if_fail (brightness >= 0. && brightness <= 1.);
-  g_return_if_fail (sharpness >= 0.);
-
-  priv = self->priv;
-
-  enabled = enabled != FALSE;
-
-  if (enabled != priv->vignette)
-    {
-      priv->vignette = enabled;
-      invalidate_pipeline (self, CHANGED_EFFECTS);
-      changed = TRUE;
-    }
-
-  if (brightness != priv->brightness || sharpness != priv->vignette_sharpness)
-    {
-      priv->brightness = brightness;
-      priv->vignette_sharpness = sharpness;
-      invalidate_pipeline (self, CHANGED_VIGNETTE_PARAMETERS);
-      changed = TRUE;
-    }
-
-  if (changed)
-    clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
diff '--exclude=.git' -urN a/src/compositor/meta-background-image.c b/src/compositor/meta-background-image.c
--- a/src/compositor/meta-background-image.c	2016-08-29 18:17:55.000000000 -0400
+++ b/src/compositor/meta-background-image.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,359 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * Copyright 2014 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-/**
- * SECTION:meta-background-image
- * @title: MetaBackgroundImage
- * @short_description: objects holding images loaded from files, used for backgrounds
- */
-
-#include <config.h>
-
-#include <gio/gio.h>
-#include <gdk-pixbuf/gdk-pixbuf.h>
-#include <clutter/clutter.h>
-#include <meta/meta-background-image.h>
-#include "cogl-utils.h"
-
-enum
-{
-  LOADED,
-  LAST_SIGNAL
-};
-
-static guint signals[LAST_SIGNAL] = { 0 };
-
-struct _MetaBackgroundImageCache
-{
-  GObject parent_instance;
-
-  GHashTable *images;
-};
-
-struct _MetaBackgroundImageCacheClass
-{
-  GObjectClass parent_class;
-};
-
-struct _MetaBackgroundImage
-{
-  GObject parent_instance;
-  GFile *file;
-  MetaBackgroundImageCache *cache;
-  gboolean in_cache;
-  gboolean loaded;
-  CoglTexture *texture;
-};
-
-struct _MetaBackgroundImageClass
-{
-  GObjectClass parent_class;
-};
-
-G_DEFINE_TYPE (MetaBackgroundImageCache, meta_background_image_cache, G_TYPE_OBJECT);
-
-static void
-meta_background_image_cache_init (MetaBackgroundImageCache *cache)
-{
-  cache->images = g_hash_table_new (g_file_hash, (GEqualFunc) g_file_equal);
-}
-
-static void
-meta_background_image_cache_finalize (GObject *object)
-{
-  MetaBackgroundImageCache *cache = META_BACKGROUND_IMAGE_CACHE (object);
-  GHashTableIter iter;
-  gpointer key, value;
-
-  g_hash_table_iter_init (&iter, cache->images);
-  while (g_hash_table_iter_next (&iter, &key, &value))
-    {
-      MetaBackgroundImage *image = value;
-      image->in_cache = FALSE;
-    }
-
-  g_hash_table_destroy (cache->images);
-
-  G_OBJECT_CLASS (meta_background_image_cache_parent_class)->finalize (object);
-}
-
-static void
-meta_background_image_cache_class_init (MetaBackgroundImageCacheClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = meta_background_image_cache_finalize;
-}
-
-/**
- * meta_background_image_cache_get_default:
- *
- * Return value: (transfer none): the global singleton background cache
- */
-MetaBackgroundImageCache *
-meta_background_image_cache_get_default (void)
-{
-  static MetaBackgroundImageCache *cache;
-
-  if (cache == NULL)
-    cache = g_object_new (META_TYPE_BACKGROUND_IMAGE_CACHE, NULL);
-
-  return cache;
-}
-
-static void
-load_file (GTask               *task,
-           MetaBackgroundImage *image,
-           gpointer             task_data,
-           GCancellable        *cancellable)
-{
-  GError *error = NULL;
-  GdkPixbuf *pixbuf;
-  GFileInputStream *stream;
-
-  stream = g_file_read (image->file, NULL, &error);
-  if (stream == NULL)
-    {
-      g_task_return_error (task, error);
-      return;
-    }
-
-  pixbuf = gdk_pixbuf_new_from_stream (G_INPUT_STREAM (stream), NULL, &error);
-  g_object_unref (stream);
-
-  if (pixbuf == NULL)
-    {
-      g_task_return_error (task, error);
-      return;
-    }
-
-  g_task_return_pointer (task, pixbuf, (GDestroyNotify) g_object_unref);
-}
-
-static void
-file_loaded (GObject      *source_object,
-             GAsyncResult *result,
-             gpointer      user_data)
-{
-  MetaBackgroundImage *image = META_BACKGROUND_IMAGE (source_object);
-  GError *error = NULL;
-  CoglError *catch_error = NULL;
-  GTask *task;
-  CoglTexture *texture;
-  GdkPixbuf *pixbuf;
-  int width, height, row_stride;
-  guchar *pixels;
-  gboolean has_alpha;
-
-  task = G_TASK (result);
-  pixbuf = g_task_propagate_pointer (task, &error);
-
-  if (pixbuf == NULL)
-    {
-      char *uri = g_file_get_uri (image->file);
-      g_warning ("Failed to load background '%s': %s",
-                 uri, error->message);
-      g_clear_error (&error);
-      g_free (uri);
-      goto out;
-    }
-
-  width = gdk_pixbuf_get_width (pixbuf);
-  height = gdk_pixbuf_get_height (pixbuf);
-  row_stride = gdk_pixbuf_get_rowstride (pixbuf);
-  pixels = gdk_pixbuf_get_pixels (pixbuf);
-  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
-
-  texture = meta_create_texture (width, height,
-                                 has_alpha ? COGL_TEXTURE_COMPONENTS_RGBA : COGL_TEXTURE_COMPONENTS_RGB,
-                                 META_TEXTURE_ALLOW_SLICING);
-
-  if (!cogl_texture_set_data (texture,
-                              has_alpha ? COGL_PIXEL_FORMAT_RGBA_8888 : COGL_PIXEL_FORMAT_RGB_888,
-                              row_stride,
-                              pixels, 0,
-                              &catch_error))
-    {
-      g_warning ("Failed to create texture for background");
-      cogl_error_free (catch_error);
-      cogl_object_unref (texture);
-    }
-
-  image->texture = texture;
-
-out:
-  if (pixbuf != NULL)
-    g_object_unref (pixbuf);
-
-  image->loaded = TRUE;
-  g_signal_emit (image, signals[LOADED], 0);
-}
-
-/**
- * meta_background_image_cache_load:
- * @cache: a #MetaBackgroundImageCache
- * @file: #GFile to load
- *
- * Loads an image to use as a background, or returns a reference to an
- * image that is already in the process of loading or loaded. In either
- * case, what is returned is a #MetaBackgroundImage which can be derefenced
- * to get a #CoglTexture. If meta_background_image_is_loaded() returns %TRUE,
- * the background is loaded, otherwise the MetaBackgroundImage::loaded
- * signal will be emitted exactly once. The 'loaded' state means that the
- * loading process finished, whether it succeeded or failed.
- *
- * Return value: (transfer full): a #MetaBackgroundImage to dereference to get the loaded texture
- */
-MetaBackgroundImage *
-meta_background_image_cache_load (MetaBackgroundImageCache *cache,
-                                  GFile                    *file)
-{
-  MetaBackgroundImage *image;
-  GTask *task;
-
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE_CACHE (cache), NULL);
-  g_return_val_if_fail (file != NULL, NULL);
-
-  image = g_hash_table_lookup (cache->images, file);
-  if (image != NULL)
-    return g_object_ref (image);
-
-  image = g_object_new (META_TYPE_BACKGROUND_IMAGE, NULL);
-  image->cache = cache;
-  image->in_cache = TRUE;
-  image->file = g_object_ref (file);
-  g_hash_table_insert (cache->images, image->file, image);
-
-  task = g_task_new (image, NULL, file_loaded, NULL);
-
-  g_task_run_in_thread (task, (GTaskThreadFunc) load_file);
-  g_object_unref (task);
-
-  return image;
-}
-
-/**
- * meta_background_image_cache_purge:
- * @cache: a #MetaBackgroundImageCache
- * @file: file to remove from the cache
- *
- * Remove an entry from the cache; this would be used if monitoring
- * showed that the file changed.
- */
-void
-meta_background_image_cache_purge (MetaBackgroundImageCache *cache,
-                                   GFile                    *file)
-{
-  MetaBackgroundImage *image;
-
-  g_return_if_fail (META_IS_BACKGROUND_IMAGE_CACHE (cache));
-  g_return_if_fail (file != NULL);
-
-  image = g_hash_table_lookup (cache->images, file);
-  if (image == NULL)
-    return;
-
-  g_hash_table_remove (cache->images, image->file);
-  image->in_cache = FALSE;
-}
-
-G_DEFINE_TYPE (MetaBackgroundImage, meta_background_image, G_TYPE_OBJECT);
-
-static void
-meta_background_image_init (MetaBackgroundImage *image)
-{
-}
-
-static void
-meta_background_image_finalize (GObject *object)
-{
-  MetaBackgroundImage *image = META_BACKGROUND_IMAGE (object);
-
-  if (image->in_cache)
-    g_hash_table_remove (image->cache->images, image->file);
-
-  if (image->texture)
-    cogl_object_unref (image->texture);
-  if (image->file)
-    g_object_unref (image->file);
-
-  G_OBJECT_CLASS (meta_background_image_parent_class)->finalize (object);
-}
-
-static void
-meta_background_image_class_init (MetaBackgroundImageClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = meta_background_image_finalize;
-
-  signals[LOADED] =
-    g_signal_new ("loaded",
-                  G_TYPE_FROM_CLASS (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  0,
-                  NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
-}
-
-/**
- * meta_background_image_is_loaded:
- * @image: a #MetaBackgroundImage
- *
- * Return value: %TRUE if loading has already completed, %FALSE otherwise
- */
-gboolean
-meta_background_image_is_loaded (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), FALSE);
-
-  return image->loaded;
-}
-
-/**
- * meta_background_image_get_success:
- * @image: a #MetaBackgroundImage
- *
- * This function is a convenience function for checking for success,
- * without having to call meta_background_image_get_texture() and
- * handle the return of a Cogl type.
- *
- * Return value: %TRUE if loading completed successfully, otherwise %FALSE
- */
-gboolean
-meta_background_image_get_success (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), FALSE);
-
-  return image->texture != NULL;
-}
-
-/**
- * meta_background_image_get_texture:
- * @image: a #MetaBackgroundImage
- *
- * Return value: (transfer none): a #CoglTexture if loading succeeded; if
- *  loading failed or has not yet finished, %NULL.
- */
-CoglTexture *
-meta_background_image_get_texture (MetaBackgroundImage *image)
-{
-  g_return_val_if_fail (META_IS_BACKGROUND_IMAGE (image), NULL);
-
-  return image->texture;
-}
diff '--exclude=.git' -urN a/src/compositor/meta-background-private.h b/src/compositor/meta-background-private.h
--- a/src/compositor/meta-background-private.h	2016-07-29 00:51:39.000000000 -0400
+++ b/src/compositor/meta-background-private.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-
-#ifndef META_BACKGROUND_PRIVATE_H
-#define META_BACKGROUND_PRIVATE_H
-
-#include <config.h>
-
-#include "meta-background-private.h"
-
-CoglTexture *meta_background_get_texture (MetaBackground         *self,
-                                          int                     monitor_index,
-                                          cairo_rectangle_int_t  *texture_area,
-                                          CoglPipelineWrapMode   *wrap_mode);
-
-#endif /* META_BACKGROUND_PRIVATE_H */
diff '--exclude=.git' -urN a/src/compositor/meta-background.c b/src/compositor/meta-background.c
--- a/src/compositor/meta-background.c	2016-08-29 18:17:55.000000000 -0400
+++ b/src/compositor/meta-background.c	2016-09-27 23:33:36.543633534 -0400
@@ -17,350 +17,731 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <meta/util.h>
-#include <meta/meta-background.h>
-#include <meta/meta-background-image.h>
-#include "meta-background-private.h"
-#include "cogl-utils.h"
-
-#include <string.h>
+/**
+ * SECTION:meta-background
+ * @title: MetaBackground
+ * @short_description: ClutterContent for painting the system background
+ *
+ */
 
-enum
-{
-  CHANGED,
-  LAST_SIGNAL
-};
+#include <config.h>
 
-static guint signals[LAST_SIGNAL] = { 0 };
+#include <clutter/clutter.h>
 
-typedef struct _MetaBackgroundMonitor MetaBackgroundMonitor;
+#include "cogl-utils.h"
+#include "compositor-private.h"
+#include "meta/meta-enum-types.h"
+#include <meta/errors.h>
+#include <meta/meta-background.h>
+#include "util-private.h"
+#include "meta-background-actor-private.h"
 
-struct _MetaBackgroundMonitor
-{
-  gboolean dirty;
-  CoglTexture *texture;
-  CoglFramebuffer *fbo;
-};
+#define FRAGMENT_SHADER_DECLARATIONS                                           \
+"uniform vec2 texture_scale;\n"                                                \
+"uniform vec2 actor_size;\n"                                                   \
+"uniform vec2 offset;\n"                                                       \
+"uniform float brightness;\n"                                                  \
+"uniform float vignette_sharpness;\n"                                          \
+
+#define VIGNETTE_CODE                                                          \
+"vec2 position = cogl_tex_coord_in[0].xy * texture_scale - offset;\n"          \
+"float t = length(2.0 * (position / actor_size));\n"                           \
+"t = clamp(t, 0.0, 1.0);\n"                                                    \
+"float pixel_brightness = mix(1.0, 1.0 - vignette_sharpness, t);\n"            \
+"cogl_color_out.rgb = cogl_color_out.rgb * pixel_brightness * brightness;\n"
+
+/* We allow creating multiple MetaBackgrounds for the same monitor to
+ * allow different rendering options to be set for different copies.
+ * But we want to share the same underlying CoglTextures for efficiency and
+ * to avoid driver bugs that might occur if we created multiple CoglTexturePixmaps
+ * for the same pixmap.
+ *
+ * This object provides a ClutterContent object to assist in sharing between actors.
+ */
 
 struct _MetaBackgroundPrivate
 {
-  MetaScreen *screen;
-  MetaBackgroundMonitor *monitors;
-  int n_monitors;
+  MetaScreen   *screen;
+  CoglTexture  *texture;
+  CoglPipeline *pipeline;
+  int           monitor;
+
+  MetaBackgroundEffects effects;
 
   GDesktopBackgroundStyle   style;
   GDesktopBackgroundShading shading_direction;
   ClutterColor              color;
   ClutterColor              second_color;
 
-  GFile *file1;
-  MetaBackgroundImage *background_image1;
-  GFile *file2;
-  MetaBackgroundImage *background_image2;
-
-  CoglTexture *color_texture;
-  CoglTexture *wallpaper_texture;
-
-  float blend_factor;
+  char  *filename;
 
-  guint wallpaper_allocation_failed : 1;
+  float brightness;
+  float vignette_sharpness;
 };
 
 enum
 {
   PROP_META_SCREEN = 1,
   PROP_MONITOR,
+  PROP_EFFECTS,
+  PROP_BRIGHTNESS,
+  PROP_VIGNETTE_SHARPNESS,
 };
 
-G_DEFINE_TYPE (MetaBackground, meta_background, G_TYPE_OBJECT)
+static void clutter_content_iface_init (ClutterContentIface *iface);
+static void unset_texture (MetaBackground *self);
+
+G_DEFINE_TYPE_WITH_CODE (MetaBackground, meta_background, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (CLUTTER_TYPE_CONTENT,
+                                                clutter_content_iface_init))
+
+static gboolean
+meta_background_get_preferred_size (ClutterContent *content,
+                                    gfloat         *width,
+                                    gfloat         *height)
+{
+  MetaBackgroundPrivate *priv = META_BACKGROUND (content)->priv;
+  MetaRectangle monitor_geometry;
+
+  if (priv->texture == NULL)
+    return FALSE;
+
+  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
 
-static gboolean texture_has_alpha (CoglTexture *texture);
+  if (width != NULL)
+    *width = monitor_geometry.width;
 
-static GSList *all_backgrounds = NULL;
+  if (height != NULL)
+    *height = monitor_geometry.height;
+
+  return TRUE;
+}
 
 static void
-free_fbos (MetaBackground *self)
+get_texture_area_and_scale (MetaBackground        *self,
+                            ClutterActorBox       *actor_box,
+                            cairo_rectangle_int_t *texture_area,
+                            float                 *texture_x_scale,
+                            float                 *texture_y_scale)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  MetaRectangle monitor_geometry;
+  cairo_rectangle_int_t actor_pixel_rect;
+  cairo_rectangle_int_t image_area;
+  int screen_width, screen_height;
+  float texture_width, texture_height;
+  float actor_x_scale, actor_y_scale;
+  float monitor_x_scale, monitor_y_scale;
+  float x_offset, y_offset;
 
-  int i;
+  meta_screen_get_monitor_geometry (priv->screen, priv->monitor, &monitor_geometry);
 
-  for (i = 0; i < priv->n_monitors; i++)
+  actor_pixel_rect.x = actor_box->x1;
+  actor_pixel_rect.y = actor_box->y1;
+  actor_pixel_rect.width = actor_box->x2 - actor_box->x1;
+  actor_pixel_rect.height = actor_box->y2 - actor_box->y1;
+
+  texture_width = cogl_texture_get_width (priv->texture);
+  actor_x_scale = (1.0 * actor_pixel_rect.width / monitor_geometry.width);
+
+  texture_height = cogl_texture_get_height (priv->texture);
+  actor_y_scale = (1.0 * actor_pixel_rect.height / monitor_geometry.height);
+
+  switch (priv->style)
     {
-      MetaBackgroundMonitor *monitor = &priv->monitors[i];
-      if (monitor->fbo)
-        {
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
-        }
-      if (monitor->texture)
+      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
+      default:
+          /* paint region is whole actor, and the texture
+           * is scaled disproportionately to fit the actor
+           */
+          *texture_area = actor_pixel_rect;
+          *texture_x_scale = 1.0 / actor_pixel_rect.width;
+          *texture_y_scale = 1.0 / actor_pixel_rect.height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
+          /* The wallpaper should be centered in the middle of all monitors.
+           * Therefore, the textured area is the union of all monitors plus
+           * an additional bit to make up for the texture getting centered.  */
+          meta_screen_get_size (priv->screen, &screen_width, &screen_height);
+
+          /* so start by making the unclipped texture area the whole screen */
+          image_area.width = screen_width;
+          image_area.height = screen_height;
+
+          /* If one of the tiles is already centered in the screen, then that tile
+           * will start tile_size/2.0 before the center of the screen. So find out
+           * how far we are from that ideal and adjust by that offset.
+           */
+          x_offset = texture_width - ((int) ((screen_width / 2.0) - (texture_width / 2.0))) % ((int) texture_width);
+          y_offset = texture_height - ((int) ((screen_height / 2.0) - (texture_height / 2.0))) % ((int) texture_height);
+
+          image_area.width += x_offset;
+          image_area.height += y_offset;
+          image_area.x = -x_offset;
+          image_area.y = -y_offset;
+
+          /* now line up with the appropriate monitor */
+          image_area.x -= monitor_geometry.x;
+          image_area.y -= monitor_geometry.y;
+
+          /* and scale to actor */
+          image_area.x *= actor_x_scale;
+          image_area.y *= actor_y_scale;
+          image_area.width *= actor_x_scale;
+          image_area.height *= actor_y_scale;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / texture_width;
+          *texture_y_scale = 1.0 / texture_height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
+          /* paint region is the original image size centered in the actor,
+           * and the texture is scaled to the original image size */
+          image_area.width = texture_width;
+          image_area.height = texture_height;
+          image_area.x = actor_pixel_rect.x + actor_pixel_rect.width / 2 - image_area.width / 2;
+          image_area.y = actor_pixel_rect.y + actor_pixel_rect.height / 2 - image_area.height / 2;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / texture_width;
+          *texture_y_scale = 1.0 / texture_height;
+          break;
+      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
+      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
+          /* paint region is the actor size in one dimension, and centered and
+           * scaled by proportional amount in the other dimension.
+           *
+           * SCALED forces the centered dimension to fit on screen.
+           * ZOOM forces the centered dimension to grow off screen
+           */
+          monitor_x_scale = monitor_geometry.width / texture_width;
+          monitor_y_scale = monitor_geometry.height / texture_height;
+
+          if ((priv->style == G_DESKTOP_BACKGROUND_STYLE_SCALED &&
+                (monitor_x_scale < monitor_y_scale)) ||
+              (priv->style == G_DESKTOP_BACKGROUND_STYLE_ZOOM &&
+                (monitor_x_scale > monitor_y_scale)))
+            {
+              /* Fill image to exactly fit actor horizontally */
+              image_area.width = actor_pixel_rect.width;
+              image_area.height = texture_height * monitor_x_scale * actor_y_scale;
+
+              /* Position image centered vertically in actor */
+              image_area.x = actor_pixel_rect.x;
+              image_area.y = actor_pixel_rect.y + actor_pixel_rect.height / 2 - image_area.height / 2;
+            }
+          else
+            {
+              /* Scale image to exactly fit actor vertically */
+              image_area.width = texture_width * monitor_y_scale * actor_x_scale;
+              image_area.height = actor_pixel_rect.height;
+
+              /* Position image centered horizontally in actor */
+              image_area.x = actor_pixel_rect.x + actor_pixel_rect.width / 2 - image_area.width / 2;
+              image_area.y = actor_pixel_rect.y;
+            }
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / image_area.width;
+          *texture_y_scale = 1.0 / image_area.height;
+          break;
+
+      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
         {
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
+          /* paint region is the union of all monitors, with the origin
+           * of the region set to align with monitor associated with the background.
+           */
+          meta_screen_get_size (priv->screen, &screen_width, &screen_height);
+
+          /* unclipped texture area is whole screen */
+          image_area.width = screen_width * actor_x_scale;
+          image_area.height = screen_height * actor_y_scale;
+
+          /* But make (0,0) line up with the appropriate monitor */
+          image_area.x = -monitor_geometry.x * actor_x_scale;
+          image_area.y = -monitor_geometry.y * actor_y_scale;
+
+          *texture_area = image_area;
+          *texture_x_scale = 1.0 / image_area.width;
+          *texture_y_scale = 1.0 / image_area.height;
+          break;
         }
     }
 }
 
-static void
-free_color_texture (MetaBackground *self)
+static CoglPipelineWrapMode
+get_wrap_mode (MetaBackground *self)
 {
   MetaBackgroundPrivate *priv = self->priv;
-
-  if (priv->color_texture != NULL)
+  switch (priv->style)
     {
-      cogl_object_unref (priv->color_texture);
-      priv->color_texture = NULL;
+      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
+          return COGL_PIPELINE_WRAP_MODE_REPEAT;
+      case G_DESKTOP_BACKGROUND_STYLE_NONE:
+      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
+      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
+      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
+      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
+      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
+      default:
+          return COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
     }
 }
 
-static void
-free_wallpaper_texture (MetaBackground *self)
+static gboolean
+texture_has_alpha (CoglTexture *texture)
 {
-  MetaBackgroundPrivate *priv = self->priv;
+  if (!texture)
+    return FALSE;
 
-  if (priv->wallpaper_texture != NULL)
+  switch (cogl_texture_get_components (texture))
     {
-      cogl_object_unref (priv->wallpaper_texture);
-      priv->wallpaper_texture = NULL;
+    case COGL_TEXTURE_COMPONENTS_A:
+    case COGL_TEXTURE_COMPONENTS_RGBA:
+      return TRUE;
+    case COGL_TEXTURE_COMPONENTS_RG:
+    case COGL_TEXTURE_COMPONENTS_RGB:
+    case COGL_TEXTURE_COMPONENTS_DEPTH:
+      return FALSE;
+    default:
+      g_assert_not_reached ();
     }
-
-  priv->wallpaper_allocation_failed = FALSE;
 }
 
-static void
-on_monitors_changed (MetaScreen     *screen,
-                     MetaBackground *self)
+static ClutterPaintNode *
+meta_background_paint_node_new (MetaBackground *self,
+                                ClutterActor   *actor)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  ClutterPaintNode *node;
+  guint8 opacity;
+  guint8 color_component;
+  gboolean needs_blending;
+
+  opacity = clutter_actor_get_paint_opacity (actor);
+  color_component = (guint8) (0.5 + opacity * priv->brightness);
+
+  cogl_pipeline_set_color4ub (priv->pipeline,
+                              color_component,
+                              color_component,
+                              color_component,
+                              opacity);
+
+  node = clutter_pipeline_node_new (priv->pipeline);
+
+  needs_blending = (opacity < 255) || (texture_has_alpha (priv->texture));
+
+  if (needs_blending)
+    cogl_pipeline_set_blend (priv->pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))", NULL);
+  else
+    cogl_pipeline_set_blend (priv->pipeline, "RGBA = ADD (SRC_COLOR, 0)", NULL);
 
-  free_fbos (self);
-  g_free (priv->monitors);
-  priv->monitors = NULL;
-  priv->n_monitors = 0;
+  return node;
+}
 
-  if (priv->screen)
-    {
-      int i;
+static void
+clip_region_to_actor_box (cairo_region_t  *region,
+                          ClutterActorBox *actor_box)
+{
+  cairo_rectangle_int_t clip_rect;
 
-      priv->n_monitors = meta_screen_get_n_monitors (screen);
-      priv->monitors = g_new0 (MetaBackgroundMonitor, priv->n_monitors);
+  clip_rect.x = actor_box->x1;
+  clip_rect.y = actor_box->y1;
+  clip_rect.width = actor_box->x2 - actor_box->x1;
+  clip_rect.height = actor_box->y2 - actor_box->y1;
 
-      for (i = 0; i < priv->n_monitors; i++)
-        priv->monitors[i].dirty = TRUE;
-    }
+  cairo_region_intersect_rectangle (region, &clip_rect);
 }
 
 static void
-set_screen (MetaBackground *self,
-            MetaScreen     *screen)
+set_vignette_parameters (MetaBackground        *self,
+                         ClutterActorBox       *actor_box,
+                         cairo_rectangle_int_t *texture_area,
+                         float                  texture_x_scale,
+                         float                  texture_y_scale)
 {
   MetaBackgroundPrivate *priv = self->priv;
+  float                  texture_scale[2];
+  float                  actor_size[2];
+  float                  offset[2];
+
+  if (!(priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE))
+    return;
+
+  texture_scale[0] = 1.0 / texture_x_scale;
+  texture_scale[1] = 1.0 / texture_y_scale;
+  actor_size[0] = actor_box->x2 - actor_box->x1;
+  actor_size[1] = actor_box->y2 - actor_box->y1;
+  offset[0] = -texture_area->x + (actor_size[0] / 2.0);
+  offset[1] = -texture_area->y + (actor_size[1] / 2.0);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "texture_scale"),
+                                   2, 1, texture_scale);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "actor_size"),
+                                   2, 1, actor_size);
+
+  cogl_pipeline_set_uniform_float (priv->pipeline,
+                                   cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                       "offset"),
+                                   2, 1, offset);
+}
 
-  if (priv->screen != NULL)
-    {
-      g_signal_handlers_disconnect_by_func (priv->screen,
-                                            (gpointer)on_monitors_changed,
-                                            self);
-    }
+static void
+meta_background_paint_content (ClutterContent   *content,
+                               ClutterActor     *actor,
+                               ClutterPaintNode *root)
+{
+  MetaBackground *self = META_BACKGROUND (content);
+  MetaBackgroundPrivate *priv = self->priv;
+  ClutterPaintNode *node;
+  ClutterActorBox actor_box;
+  cairo_rectangle_int_t texture_area;
+  cairo_region_t *paintable_region = NULL;
+  int n_texture_subareas;
+  int i;
+  float texture_x_scale, texture_y_scale;
+  float tx1 = 0.0, ty1 = 0.0, tx2 = 1.0, ty2 = 1.0;
 
-  priv->screen = screen;
+  if (priv->texture == NULL)
+    return;
 
-  if (priv->screen != NULL)
+  clutter_actor_get_content_box (actor, &actor_box);
+
+  /* First figure out where on the monitor the texture is supposed to be painted.
+   * If the actor is not the size of the monitor, this function makes sure to scale
+   * everything down to fit in the actor.
+   */
+  get_texture_area_and_scale (self,
+                              &actor_box,
+                              &texture_area,
+                              &texture_x_scale,
+                              &texture_y_scale);
+
+  set_vignette_parameters (self, &actor_box, &texture_area, texture_x_scale, texture_y_scale);
+
+  /* Now figure out what to actually paint. We start by clipping the texture area to
+   * the actor's bounds.
+   */
+  paintable_region = cairo_region_create_rectangle (&texture_area);
+
+  clip_region_to_actor_box (paintable_region, &actor_box);
+
+  /* And then cut out any parts occluded by window actors
+   */
+  if (META_IS_BACKGROUND_ACTOR (actor))
     {
-      g_signal_connect (priv->screen, "monitors-changed",
-                        G_CALLBACK (on_monitors_changed), self);
+      cairo_region_t *clip_region;
+      clip_region = meta_background_actor_get_clip_region (META_BACKGROUND_ACTOR (actor));
+
+      if (clip_region != NULL)
+        cairo_region_intersect (paintable_region, clip_region);
     }
 
-  on_monitors_changed (priv->screen, self);
-}
+  if (cairo_region_is_empty (paintable_region))
+    goto out;
 
-static void
-meta_background_set_property (GObject      *object,
-                              guint         prop_id,
-                              const GValue *value,
-                              GParamSpec   *pspec)
-{
-  switch (prop_id)
+  node = meta_background_paint_node_new (self, actor);
+
+  /* Finally, split the paintable region up into distinct areas
+   * and paint each area one by one
+   */
+  n_texture_subareas = cairo_region_num_rectangles (paintable_region);
+  for (i = 0; i < n_texture_subareas; i++)
     {
-    case PROP_META_SCREEN:
-      set_screen (META_BACKGROUND (object), g_value_get_object (value));
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
+      cairo_rectangle_int_t texture_subarea;
+      ClutterActorBox texture_rectangle;
+
+      cairo_region_get_rectangle (paintable_region, i, &texture_subarea);
+
+      tx1 = (texture_subarea.x - texture_area.x) * texture_x_scale;
+      ty1 = (texture_subarea.y - texture_area.y) * texture_y_scale;
+      tx2 = (texture_subarea.x + texture_subarea.width - texture_area.x) * texture_x_scale;
+      ty2 = (texture_subarea.y + texture_subarea.height - texture_area.y) * texture_y_scale;
+      texture_rectangle.x1 = texture_subarea.x;
+      texture_rectangle.y1 = texture_subarea.y;
+      texture_rectangle.x2 = texture_subarea.x + texture_subarea.width;
+      texture_rectangle.y2 = texture_subarea.y + texture_subarea.height;
+
+      clutter_paint_node_add_texture_rectangle (node, &texture_rectangle, tx1, ty1, tx2, ty2);
     }
+  clutter_paint_node_add_child (root, node);
+  clutter_paint_node_unref (node);
+
+ out:
+  cairo_region_destroy (paintable_region);
 }
 
 static void
-meta_background_get_property (GObject      *object,
-                              guint         prop_id,
-                              GValue       *value,
-                              GParamSpec   *pspec)
+clutter_content_iface_init (ClutterContentIface *iface)
 {
-  MetaBackgroundPrivate *priv = META_BACKGROUND (object)->priv;
-
-  switch (prop_id)
-    {
-    case PROP_META_SCREEN:
-      g_value_set_object (value, priv->screen);
-      break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-      break;
-    }
+  iface->get_preferred_size = meta_background_get_preferred_size;
+  iface->paint_content = meta_background_paint_content;
 }
 
-static gboolean
-need_prerender (MetaBackground *self)
+static void
+meta_background_dispose (GObject *object)
 {
+  MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
-  CoglTexture *texture1 = priv->background_image1 ? meta_background_image_get_texture (priv->background_image1) : NULL;
-  CoglTexture *texture2 = priv->background_image2 ? meta_background_image_get_texture (priv->background_image2) : NULL;
 
-  if (texture1 == NULL && texture2 == NULL)
-    return FALSE;
+  unset_texture (self);
 
-  if (texture2 == NULL && priv->style == G_DESKTOP_BACKGROUND_STYLE_WALLPAPER)
-    return FALSE;
+  g_clear_pointer (&priv->pipeline,
+                   (GDestroyNotify)
+                   cogl_object_unref);
 
-  return TRUE;
+  G_OBJECT_CLASS (meta_background_parent_class)->dispose (object);
 }
 
 static void
-mark_changed (MetaBackground *self)
+meta_background_finalize (GObject *object)
 {
+  MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
-  int i;
-
-  if (!need_prerender (self))
-    free_fbos (self);
 
-  for (i = 0; i < priv->n_monitors; i++)
-    priv->monitors[i].dirty = TRUE;
+  g_free (priv->filename);
 
-  g_signal_emit (self, signals[CHANGED], 0);
+  G_OBJECT_CLASS (meta_background_parent_class)->finalize (object);
 }
 
 static void
-on_background_loaded (MetaBackgroundImage *image,
-                      MetaBackground      *self)
+ensure_pipeline (MetaBackground *self)
 {
-  mark_changed (self);
+  if (self->priv->pipeline == NULL)
+    self->priv->pipeline = COGL_PIPELINE (meta_create_texture_pipeline (NULL));
 }
 
-static gboolean
-file_equal0 (GFile *file1,
-             GFile *file2)
+static void
+set_brightness (MetaBackground *self,
+                gfloat          brightness)
 {
-  if (file1 == file2)
-    return TRUE;
+  MetaBackgroundPrivate *priv = self->priv;
 
-  if ((file1 == NULL) || (file2 == NULL))
-    return FALSE;
+  if (priv->brightness == brightness)
+    return;
+
+  priv->brightness = brightness;
+
+  if (clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL) &&
+      priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+    {
+      ensure_pipeline (self);
+      cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                    cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                        "brightness"),
+                                    priv->brightness);
+    }
+  else
+    {
+      ensure_pipeline (self);
+      CoglColor blend_color;
+      cogl_color_init_from_4f (&blend_color, brightness, brightness, brightness, 1.0);
+      cogl_pipeline_set_layer_combine (priv->pipeline, 1, "RGB=MODULATE(PREVIOUS, CONSTANT) A=REPLACE(PREVIOUS)", NULL);
+      cogl_pipeline_set_layer_combine_constant (priv->pipeline, 1, &blend_color);
+    }
 
-  return g_file_equal (file1, file2);
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
+
+  g_object_notify (G_OBJECT (self), "brightness");
 }
 
 static void
-set_file (MetaBackground       *self,
-          GFile               **filep,
-          MetaBackgroundImage **imagep,
-          GFile                *file)
+set_vignette_sharpness (MetaBackground *self,
+                        gfloat          sharpness)
 {
-  if (!file_equal0 (*filep, file))
-    {
-      g_clear_object (filep);
+  MetaBackgroundPrivate *priv = self->priv;
 
-      if (*imagep)
-        {
-          g_signal_handlers_disconnect_by_func (*imagep,
-                                                (gpointer)on_background_loaded,
-                                                self);
-          g_object_unref (*imagep);
-          *imagep = NULL;
-        }
+  if (priv->vignette_sharpness == sharpness)
+    return;
 
-      if (file)
-        {
-          MetaBackgroundImageCache *cache = meta_background_image_cache_get_default ();
+  priv->vignette_sharpness = sharpness;
 
-          *filep = g_object_ref (file);
-          *imagep = meta_background_image_cache_load (cache, file);
-          g_signal_connect (*imagep, "loaded",
-                            G_CALLBACK (on_background_loaded), self);
-        }
+  if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
+    return;
+
+  if (priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+    {
+      ensure_pipeline (self);
+      cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                    cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                        "vignette_sharpness"),
+                                    priv->vignette_sharpness);
     }
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
+
+  g_object_notify (G_OBJECT (self), "vignette-sharpness");
 }
 
 static void
-meta_background_dispose (GObject *object)
+add_vignette (MetaBackground *self)
 {
-  MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
+  static CoglSnippet *snippet = NULL;
 
-  free_color_texture (self);
-  free_wallpaper_texture (self);
-
-  set_file (self, &priv->file1, &priv->background_image1, NULL);
-  set_file (self, &priv->file2, &priv->background_image2, NULL);
+  if (!clutter_feature_available (CLUTTER_FEATURE_SHADERS_GLSL))
+    return;
 
-  set_screen (self, NULL);
+  ensure_pipeline (self);
 
-  G_OBJECT_CLASS (meta_background_parent_class)->dispose (object);
+  /* Cogl automatically caches pipelines with no eviction policy,
+   * so we need to prevent identical pipelines from getting cached
+   * separately, by reusing the same fragement shader snippet.
+   */
+  if (snippet == NULL)
+    snippet = cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT, FRAGMENT_SHADER_DECLARATIONS, VIGNETTE_CODE);
+
+  cogl_pipeline_add_snippet (priv->pipeline, snippet);
+
+  cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                    "brightness"),
+                                priv->brightness);
+
+  cogl_pipeline_set_uniform_1f (priv->pipeline,
+                                cogl_pipeline_get_uniform_location (priv->pipeline,
+                                                                    "vignette_sharpness"),
+                                priv->vignette_sharpness);
 }
 
 static void
-meta_background_finalize (GObject *object)
+set_effects (MetaBackground        *self,
+             MetaBackgroundEffects  effects)
 {
-  all_backgrounds = g_slist_remove (all_backgrounds, object);
+  MetaBackgroundPrivate *priv = self->priv;
 
-  G_OBJECT_CLASS (meta_background_parent_class)->finalize (object);
+  priv->effects = effects;
+
+  if ((priv->effects & META_BACKGROUND_EFFECTS_VIGNETTE))
+    add_vignette (self);
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
 }
 
 static void
-meta_background_constructed (GObject *object)
+meta_background_set_property (GObject      *object,
+                              guint         prop_id,
+                              const GValue *value,
+                              GParamSpec   *pspec)
 {
   MetaBackground        *self = META_BACKGROUND (object);
   MetaBackgroundPrivate *priv = self->priv;
 
-  G_OBJECT_CLASS (meta_background_parent_class)->constructed (object);
+  switch (prop_id)
+    {
+    case PROP_META_SCREEN:
+      priv->screen = g_value_get_object (value);
+      break;
+    case PROP_MONITOR:
+      priv->monitor = g_value_get_int (value);
+      break;
+    case PROP_EFFECTS:
+      set_effects (self, g_value_get_flags (value));
+      break;
+    case PROP_BRIGHTNESS:
+      set_brightness (self, g_value_get_float (value));
+      break;
+    case PROP_VIGNETTE_SHARPNESS:
+      set_vignette_sharpness (self, g_value_get_float (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_background_get_property (GObject      *object,
+                              guint         prop_id,
+                              GValue       *value,
+                              GParamSpec   *pspec)
+{
+  MetaBackgroundPrivate *priv = META_BACKGROUND (object)->priv;
 
-  g_signal_connect_object (meta_screen_get_display (priv->screen), "gl-video-memory-purged",
-                           G_CALLBACK (mark_changed), object, G_CONNECT_SWAPPED);
+  switch (prop_id)
+    {
+    case PROP_META_SCREEN:
+      g_value_set_object (value, priv->screen);
+      break;
+    case PROP_MONITOR:
+      g_value_set_int (value, priv->monitor);
+      break;
+    case PROP_EFFECTS:
+      g_value_set_flags (value, priv->effects);
+      break;
+    case PROP_BRIGHTNESS:
+      g_value_set_float (value, priv->brightness);
+      break;
+    case PROP_VIGNETTE_SHARPNESS:
+      g_value_set_float (value, priv->vignette_sharpness);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
 }
 
 static void
 meta_background_class_init (MetaBackgroundClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GParamSpec *param_spec;
+  GParamSpec   *param_spec;
 
   g_type_class_add_private (klass, sizeof (MetaBackgroundPrivate));
 
   object_class->dispose = meta_background_dispose;
   object_class->finalize = meta_background_finalize;
-  object_class->constructed = meta_background_constructed;
   object_class->set_property = meta_background_set_property;
   object_class->get_property = meta_background_get_property;
 
-  signals[CHANGED] =
-    g_signal_new ("changed",
-                  G_TYPE_FROM_CLASS (object_class),
-                  G_SIGNAL_RUN_LAST,
-                  0,
-                  NULL, NULL, NULL,
-                  G_TYPE_NONE, 0);
-
   param_spec = g_param_spec_object ("meta-screen",
                                     "MetaScreen",
                                     "MetaScreen",
                                     META_TYPE_SCREEN,
-                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
 
   g_object_class_install_property (object_class,
                                    PROP_META_SCREEN,
                                    param_spec);
 
+  param_spec = g_param_spec_int ("monitor",
+                                 "monitor",
+                                 "monitor",
+                                 0, G_MAXINT, 0,
+                                 G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+
+  g_object_class_install_property (object_class,
+                                   PROP_MONITOR,
+                                   param_spec);
+
+  param_spec = g_param_spec_float ("brightness",
+                                   "brightness",
+                                   "Values less than 1.0 dim background",
+                                   0.0, 1.0,
+                                   1.0,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+  g_object_class_install_property (object_class, PROP_BRIGHTNESS, param_spec);
+
+  param_spec = g_param_spec_float ("vignette-sharpness",
+                                   "vignette-sharpness",
+                                   "How obvious the vignette fringe is",
+                                   0.0, 1.0,
+                                   0.7,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT);
+  g_object_class_install_property (object_class, PROP_VIGNETTE_SHARPNESS, param_spec);
+
+  param_spec = g_param_spec_flags ("effects",
+                                   "Effects",
+                                   "Set to enable vignette",
+				   meta_background_effects_get_type (),
+                                   META_BACKGROUND_EFFECTS_NONE,
+                                   G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY);
+  g_object_class_install_property (object_class, PROP_EFFECTS, param_spec);
 }
 
 static void
@@ -369,599 +750,495 @@
   self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
                                             META_TYPE_BACKGROUND,
                                             MetaBackgroundPrivate);
-  all_backgrounds = g_slist_prepend (all_backgrounds, self);
 }
 
 static void
-set_texture_area_from_monitor_area (cairo_rectangle_int_t *monitor_area,
-                                    cairo_rectangle_int_t *texture_area)
+unset_texture (MetaBackground *self)
 {
-  texture_area->x = 0;
-  texture_area->y = 0;
-  texture_area->width = monitor_area->width;
-  texture_area->height = monitor_area->height;
+  MetaBackgroundPrivate *priv = self->priv;
+  if (priv->pipeline != NULL)
+    cogl_pipeline_set_layer_texture (priv->pipeline, 0, NULL);
+
+  g_clear_pointer (&priv->texture,
+                   (GDestroyNotify)
+                   cogl_object_unref);
 }
 
 static void
-get_texture_area (MetaBackground          *self,
-                  cairo_rectangle_int_t   *monitor_rect,
-                  CoglTexture             *texture,
-                  cairo_rectangle_int_t   *texture_area)
+set_texture (MetaBackground *self,
+             CoglTexture    *texture)
 {
   MetaBackgroundPrivate *priv = self->priv;
-  cairo_rectangle_int_t image_area;
-  int screen_width, screen_height;
-  float texture_width, texture_height;
-  float monitor_x_scale, monitor_y_scale;
-
-  texture_width = cogl_texture_get_width (texture);
-  texture_height = cogl_texture_get_height (texture);
-
-  switch (priv->style)
-    {
-    case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-    default:
-      /* paint region is whole actor, and the texture
-       * is scaled disproportionately to fit the actor
-       */
-      set_texture_area_from_monitor_area (monitor_rect, texture_area);
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-      meta_screen_get_size (priv->screen, &screen_width, &screen_height);
-
-      /* Start off by centering a tile in the middle of the
-       * total screen area.
-       */
-      image_area.x = (screen_width - texture_width) / 2.0;
-      image_area.y = (screen_height - texture_height) / 2.0;
-      image_area.width = texture_width;
-      image_area.height = texture_height;
-
-      /* Translate into the coordinate system of the particular monitor */
-      image_area.x -= monitor_rect->x;
-      image_area.y -= monitor_rect->y;
-
-      *texture_area = image_area;
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-      /* paint region is the original image size centered in the actor,
-       * and the texture is scaled to the original image size */
-      image_area.width = texture_width;
-      image_area.height = texture_height;
-      image_area.x = monitor_rect->width / 2 - image_area.width / 2;
-      image_area.y = monitor_rect->height / 2 - image_area.height / 2;
-
-      *texture_area = image_area;
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-    case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-      /* paint region is the actor size in one dimension, and centered and
-       * scaled by proportional amount in the other dimension.
-       *
-       * SCALED forces the centered dimension to fit on screen.
-       * ZOOM forces the centered dimension to grow off screen
-       */
-      monitor_x_scale = monitor_rect->width / texture_width;
-      monitor_y_scale = monitor_rect->height / texture_height;
-
-      if ((priv->style == G_DESKTOP_BACKGROUND_STYLE_SCALED &&
-           (monitor_x_scale < monitor_y_scale)) ||
-          (priv->style == G_DESKTOP_BACKGROUND_STYLE_ZOOM &&
-           (monitor_x_scale > monitor_y_scale)))
-        {
-          /* Fill image to exactly fit actor horizontally */
-          image_area.width = monitor_rect->width;
-          image_area.height = texture_height * monitor_x_scale;
-
-          /* Position image centered vertically in actor */
-          image_area.x = 0;
-          image_area.y = monitor_rect->height / 2 - image_area.height / 2;
-        }
-      else
-        {
-          /* Scale image to exactly fit actor vertically */
-          image_area.width = texture_width * monitor_y_scale;
-          image_area.height = monitor_rect->height;
-
-          /* Position image centered horizontally in actor */
-          image_area.x = monitor_rect->width / 2 - image_area.width / 2;
-          image_area.y = 0;
-        }
 
-      *texture_area = image_area;
-      break;
-
-    case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      {
-        /* paint region is the union of all monitors, with the origin
-         * of the region set to align with monitor associated with the background.
-         */
-        meta_screen_get_size (priv->screen, &screen_width, &screen_height);
-
-        /* unclipped texture area is whole screen */
-        image_area.width = screen_width;
-        image_area.height = screen_height;
-
-        /* But make (0,0) line up with the appropriate monitor */
-        image_area.x = -monitor_rect->x;
-        image_area.y = -monitor_rect->y;
-
-        *texture_area = image_area;
-        break;
-      }
-    }
+  priv->texture = texture;
+  cogl_pipeline_set_layer_texture (priv->pipeline, 0, priv->texture);
 }
 
-static gboolean
-draw_texture (MetaBackground        *self,
-              CoglFramebuffer       *framebuffer,
-              CoglPipeline          *pipeline,
-              CoglTexture           *texture,
-              cairo_rectangle_int_t *monitor_area)
+static void
+set_style (MetaBackground          *self,
+           GDesktopBackgroundStyle  style)
 {
   MetaBackgroundPrivate *priv = self->priv;
-  cairo_rectangle_int_t texture_area;
-  gboolean bare_region_visible;
+  CoglPipelineWrapMode   wrap_mode;
 
-  get_texture_area (self, monitor_area, texture, &texture_area);
-
-  switch (priv->style)
-    {
-    case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-    case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-    case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-    case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      /* Draw the entire monitor */
-      cogl_framebuffer_draw_textured_rectangle (framebuffer,
-                                                pipeline,
-                                                0,
-                                                0,
-                                                monitor_area->width,
-                                                monitor_area->height,
-                                                - texture_area.x / (float)texture_area.width,
-                                                - texture_area.y / (float)texture_area.height,
-                                                (monitor_area->width - texture_area.x) / (float)texture_area.width,
-                                                (monitor_area->height - texture_area.y) / (float)texture_area.height);
-
-      bare_region_visible = texture_has_alpha (texture);
-
-      /* Draw just the texture */
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-    case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-      cogl_framebuffer_draw_textured_rectangle (framebuffer,
-                                                pipeline,
-                                                texture_area.x, texture_area.y,
-                                                texture_area.x + texture_area.width,
-                                                texture_area.y + texture_area.height,
-                                                0, 0, 1.0, 1.0);
-      bare_region_visible = texture_has_alpha (texture) || memcmp (&texture_area, monitor_area, sizeof (cairo_rectangle_int_t)) != 0;
-      break;
-    case G_DESKTOP_BACKGROUND_STYLE_NONE:
-      bare_region_visible = TRUE;
-      break;
-    default:
-      g_return_val_if_reached(FALSE);
-    }
+  priv->style = style;
 
-  return bare_region_visible;
+  wrap_mode = get_wrap_mode (self);
+  cogl_pipeline_set_layer_wrap_mode (priv->pipeline, 0, wrap_mode);
 }
 
 static void
-ensure_color_texture (MetaBackground *self)
+set_filename (MetaBackground *self,
+              const char     *filename)
 {
   MetaBackgroundPrivate *priv = self->priv;
 
-  if (priv->color_texture == NULL)
-    {
-      ClutterBackend *backend = clutter_get_default_backend ();
-      CoglContext *ctx = clutter_backend_get_cogl_context (backend);
-      CoglError *error = NULL;
-      uint8_t pixels[6];
-      int width, height;
-
-      if (priv->shading_direction == G_DESKTOP_BACKGROUND_SHADING_SOLID)
-        {
-          width = 1;
-          height = 1;
-
-          pixels[0] = priv->color.red;
-          pixels[1] = priv->color.green;
-          pixels[2] = priv->color.blue;
-        }
-      else
-        {
-          switch (priv->shading_direction)
-            {
-            case G_DESKTOP_BACKGROUND_SHADING_VERTICAL:
-              width = 1;
-              height = 2;
-              break;
-            case G_DESKTOP_BACKGROUND_SHADING_HORIZONTAL:
-              width = 2;
-              height = 1;
-              break;
-            default:
-              g_return_if_reached ();
-            }
-
-          pixels[0] = priv->color.red;
-          pixels[1] = priv->color.green;
-          pixels[2] = priv->color.blue;
-          pixels[3] = priv->second_color.red;
-          pixels[4] = priv->second_color.green;
-          pixels[5] = priv->second_color.blue;
-        }
-
-      priv->color_texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
-                                                                         COGL_PIXEL_FORMAT_RGB_888,
-                                                                         width * 3,
-                                                                         pixels,
-                                                                         &error));
-
-      if (error != NULL)
-        {
-          meta_warning ("Failed to allocate color texture: %s\n", error->message);
-          cogl_error_free (error);
-        }
-    }
+  g_free (priv->filename);
+  priv->filename = g_strdup (filename);
 }
 
-typedef enum {
-  PIPELINE_REPLACE,
-  PIPELINE_ADD,
-  PIPELINE_OVER_REVERSE,
-} PipelineType;
-
-static CoglPipeline *
-create_pipeline (PipelineType type)
+/**
+ * meta_background_load_gradient:
+ * @self: the #MetaBackground
+ * @shading_direction: the orientation of the gradient
+ * @color: the start color of the gradient
+ * @second_color: the end color of the gradient
+ *
+ * Clears any previously set background, and sets the background gradient.
+ * The gradient starts with @color and
+ * progresses toward @second_color in the direction of @shading_direction.
+ */
+void
+meta_background_load_gradient (MetaBackground             *self,
+                               GDesktopBackgroundShading   shading_direction,
+                               ClutterColor               *color,
+                               ClutterColor               *second_color)
 {
-  const char * const blend_strings[3] = {
-    [PIPELINE_REPLACE] = "RGBA = ADD (SRC_COLOR, 0)",
-    [PIPELINE_ADD] = "RGBA = ADD (SRC_COLOR, DST_COLOR)",
-    [PIPELINE_OVER_REVERSE] = "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR)",
-  };
-  static CoglPipeline *templates[3];
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
+  MetaBackgroundPrivate *priv = self->priv;
+  CoglTexture *texture;
+  guint width, height;
+  uint8_t pixels[8];
 
-  if (templates[type] == NULL)
-    {
-      templates[type] = meta_create_texture_pipeline (NULL);
-      cogl_pipeline_set_blend (templates[type], blend_strings[type], NULL);
-    }
+  ensure_pipeline (self);
 
-  return cogl_pipeline_copy (templates[type]);
-}
+  unset_texture (self);
+  set_style (self, G_DESKTOP_BACKGROUND_STYLE_NONE);
 
-static gboolean
-texture_has_alpha (CoglTexture *texture)
-{
-  if (!texture)
-    return FALSE;
+  priv->shading_direction = shading_direction;
 
-  switch (cogl_texture_get_components (texture))
+  switch (priv->shading_direction)
     {
-    case COGL_TEXTURE_COMPONENTS_A:
-    case COGL_TEXTURE_COMPONENTS_RGBA:
-      return TRUE;
-    case COGL_TEXTURE_COMPONENTS_RG:
-    case COGL_TEXTURE_COMPONENTS_RGB:
-    case COGL_TEXTURE_COMPONENTS_DEPTH:
-      return FALSE;
-    default:
-      g_assert_not_reached ();
+      case G_DESKTOP_BACKGROUND_SHADING_VERTICAL:
+          width = 1;
+          height = 2;
+          break;
+      case G_DESKTOP_BACKGROUND_SHADING_HORIZONTAL:
+          width = 2;
+          height = 1;
+          break;
+      default:
+          g_return_if_reached ();
     }
-}
 
-static gboolean
-ensure_wallpaper_texture (MetaBackground *self,
-                          CoglTexture    *texture)
+  pixels[0] = color->red;
+  pixels[1] = color->green;
+  pixels[2] = color->blue;
+  pixels[3] = 0xFF;
+  pixels[4] = second_color->red;
+  pixels[5] = second_color->green;
+  pixels[6] = second_color->blue;
+  pixels[7] = 0xFF;
+
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
+                                                         COGL_PIXEL_FORMAT_RGB_888,
+                                                         4,
+                                                         pixels,
+                                                         NULL));
+  set_texture (self, COGL_TEXTURE (texture));
+}
+
+/**
+ * meta_background_load_color:
+ * @self: the #MetaBackground
+ * @color: a #ClutterColor to solid fill background with
+ *
+ * Clears any previously set background, and sets the
+ * background to a solid color
+ *
+ * If @color is %NULL the stage color will be used.
+ */
+void
+meta_background_load_color (MetaBackground *self,
+                            ClutterColor   *color)
 {
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
   MetaBackgroundPrivate *priv = self->priv;
+  CoglTexture  *texture;
+  ClutterActor *stage = meta_get_stage_for_screen (priv->screen);
+  ClutterColor  stage_color;
+  uint8_t pixels[4];
 
-  if (priv->wallpaper_texture == NULL && !priv->wallpaper_allocation_failed)
-    {
-      int width = cogl_texture_get_width (texture);
-      int height = cogl_texture_get_height (texture);
-      CoglOffscreen *offscreen;
-      CoglFramebuffer *fbo;
-      CoglError *catch_error = NULL;
-      CoglPipeline *pipeline;
-
-      priv->wallpaper_texture = meta_create_texture (width, height,
-                                                     COGL_TEXTURE_COMPONENTS_RGBA,
-                                                     META_TEXTURE_FLAGS_NONE);
-      offscreen = cogl_offscreen_new_with_texture (priv->wallpaper_texture);
-      fbo = COGL_FRAMEBUFFER (offscreen);
-
-      if (!cogl_framebuffer_allocate (fbo, &catch_error))
-        {
-          /* This probably means that the size of the wallpapered texture is larger
-           * than the maximum texture size; we treat it as permanent until the
-           * background is changed again.
-           */
-          cogl_error_free (catch_error);
+  ensure_pipeline (self);
 
-          cogl_object_unref (priv->wallpaper_texture);
-          priv->wallpaper_texture = NULL;
-          cogl_object_unref (fbo);
+  unset_texture (self);
+  set_style (self, G_DESKTOP_BACKGROUND_STYLE_NONE);
 
-          priv->wallpaper_allocation_failed = TRUE;
-          return FALSE;
-        }
+  if (color == NULL)
+    {
+      clutter_actor_get_background_color (stage, &stage_color);
+      color = &stage_color;
+    }
 
-      cogl_framebuffer_orthographic (fbo, 0, 0,
-                                     width, height, -1., 1.);
+  pixels[0] = color->red;
+  pixels[1] = color->green;
+  pixels[2] = color->blue;
+  pixels[3] = 0xFF;
 
-      pipeline = create_pipeline (PIPELINE_REPLACE);
-      cogl_pipeline_set_layer_texture (pipeline, 0, texture);
-      cogl_framebuffer_draw_textured_rectangle (fbo, pipeline, 0, 0, width, height,
-                                                0., 0., 1., 1.);
-      cogl_object_unref (pipeline);
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, 1, 1,
+                                                         COGL_PIXEL_FORMAT_RGB_888,
+                                                         4,
+                                                         pixels,
+                                                         NULL));
+  set_texture (self, COGL_TEXTURE (texture));
+}
 
-      if (texture_has_alpha (texture))
-        {
-          ensure_color_texture (self);
+typedef struct
+{
+  GDesktopBackgroundStyle style;
+  char *filename;
+} LoadFileTaskData;
 
-          pipeline = create_pipeline (PIPELINE_OVER_REVERSE);
-          cogl_pipeline_set_layer_texture (pipeline, 0, priv->color_texture);
-          cogl_framebuffer_draw_rectangle (fbo, pipeline, 0, 0, width, height);
-          cogl_object_unref (pipeline);
-        }
+static LoadFileTaskData *
+load_file_task_data_new (const char              *filename,
+                         GDesktopBackgroundStyle  style)
+{
+  LoadFileTaskData *task_data;
 
-      cogl_object_unref (fbo);
-    }
+  task_data = g_slice_new (LoadFileTaskData);
+  task_data->style = style;
+  task_data->filename = g_strdup (filename);
 
-  return priv->wallpaper_texture != NULL;
+  return task_data;
 }
 
-static CoglPipelineWrapMode
-get_wrap_mode (GDesktopBackgroundStyle style)
+static void
+load_file_task_data_free (LoadFileTaskData *task_data)
 {
-  switch (style)
-    {
-      case G_DESKTOP_BACKGROUND_STYLE_WALLPAPER:
-          return COGL_PIPELINE_WRAP_MODE_REPEAT;
-      case G_DESKTOP_BACKGROUND_STYLE_NONE:
-      case G_DESKTOP_BACKGROUND_STYLE_STRETCHED:
-      case G_DESKTOP_BACKGROUND_STYLE_CENTERED:
-      case G_DESKTOP_BACKGROUND_STYLE_SCALED:
-      case G_DESKTOP_BACKGROUND_STYLE_ZOOM:
-      case G_DESKTOP_BACKGROUND_STYLE_SPANNED:
-      default:
-          return COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
-    }
+  g_free (task_data->filename);
+  g_slice_free (LoadFileTaskData, task_data);
 }
 
-CoglTexture *
-meta_background_get_texture (MetaBackground         *self,
-                             int                     monitor_index,
-                             cairo_rectangle_int_t  *texture_area,
-                             CoglPipelineWrapMode   *wrap_mode)
+static void
+load_file (GTask            *task,
+           MetaBackground   *self,
+           LoadFileTaskData *task_data,
+           GCancellable     *cancellable)
 {
-  MetaBackgroundPrivate *priv;
-  MetaBackgroundMonitor *monitor;
-  MetaRectangle geometry;
-  cairo_rectangle_int_t monitor_area;
-  CoglTexture *texture1, *texture2;
+  GError *error = NULL;
+  GdkPixbuf *pixbuf;
 
-  g_return_val_if_fail (META_IS_BACKGROUND (self), NULL);
-  priv = self->priv;
-  g_return_val_if_fail (monitor_index >= 0 && monitor_index < priv->n_monitors, NULL);
+  pixbuf = gdk_pixbuf_new_from_file (task_data->filename,
+                                     &error);
 
-  monitor = &priv->monitors[monitor_index];
+  if (pixbuf == NULL)
+    {
+      g_task_return_error (task, error);
+      return;
+    }
 
-  meta_screen_get_monitor_geometry (priv->screen, monitor_index, &geometry);
-  monitor_area.x = geometry.x;
-  monitor_area.y = geometry.y;
-  monitor_area.width = geometry.width;
-  monitor_area.height = geometry.height;
+  g_task_return_pointer (task, pixbuf, (GDestroyNotify) g_object_unref);
+}
 
-  texture1 = priv->background_image1 ? meta_background_image_get_texture (priv->background_image1) : NULL;
-  texture2 = priv->background_image2 ? meta_background_image_get_texture (priv->background_image2) : NULL;
+/**
+ * meta_background_load_file_async:
+ * @self: the #MetaBackground
+ * @filename: the image file to load
+ * @style: a #GDesktopBackgroundStyle to specify how background is laid out
+ * @cancellable: a #GCancellable
+ * @callback: call back to call when file is loaded or failed to load
+ * @user_data: user data for callback
+ *
+ * Loads the specified image and uses it as the background source.
+ */
+void
+meta_background_load_file_async (MetaBackground          *self,
+                                 const char              *filename,
+                                 GDesktopBackgroundStyle  style,
+                                 GCancellable            *cancellable,
+                                 GAsyncReadyCallback      callback,
+                                 gpointer                 user_data)
+{
+    LoadFileTaskData *task_data;
+    GTask *task;
+
+    task = g_task_new (self, cancellable, callback, user_data);
+
+    task_data = load_file_task_data_new (filename, style);
+    g_task_set_task_data (task, task_data, (GDestroyNotify) load_file_task_data_free);
+
+    g_task_run_in_thread (task, (GTaskThreadFunc) load_file);
+    g_object_unref (task);
+}
+
+/**
+ * meta_background_load_file_finish:
+ * @self: the #MetaBackground
+ * @result: the result from the #GAsyncReadyCallback passed
+ *          to meta_background_load_file_async()
+ * @error: a #GError
+ *
+ * The finish function for meta_background_load_file_async().
+ *
+ * Returns: whether or not the image was loaded
+ */
+gboolean
+meta_background_load_file_finish (MetaBackground  *self,
+                                  GAsyncResult    *result,
+                                  GError         **error)
+{
+  ClutterBackend *backend = clutter_get_default_backend ();
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
+  GTask *task;
+  LoadFileTaskData *task_data;
+  CoglTexture *texture;
+  GdkPixbuf *pixbuf;
+  int width, height, row_stride;
+  guchar *pixels;
+  gboolean has_alpha;
+  gboolean loaded = FALSE;
+  CoglPixelFormat pixel_format;
 
-  if (texture1 == NULL && texture2 == NULL)
-    {
-      ensure_color_texture (self);
-      if (texture_area)
-        set_texture_area_from_monitor_area (&monitor_area, texture_area);
-      if (wrap_mode)
-        *wrap_mode = COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
-      return priv->color_texture;
-    }
+  g_return_val_if_fail (g_task_is_valid (result, self), FALSE);
 
-  if (texture2 == NULL && priv->style == G_DESKTOP_BACKGROUND_STYLE_WALLPAPER &&
-      priv->shading_direction == G_DESKTOP_BACKGROUND_SHADING_SOLID &&
-      ensure_wallpaper_texture (self, texture1))
-    {
-      if (texture_area)
-        get_texture_area (self, &monitor_area, priv->wallpaper_texture,
-                          texture_area);
-      if (wrap_mode)
-        *wrap_mode = COGL_PIPELINE_WRAP_MODE_REPEAT;
-      return priv->wallpaper_texture;
-    }
+  task = G_TASK (result);
 
-  if (monitor->dirty)
-    {
-      CoglError *catch_error = NULL;
-      gboolean bare_region_visible = FALSE;
+  pixbuf = g_task_propagate_pointer (task, error);
 
-      if (monitor->texture == NULL)
-        {
-          CoglOffscreen *offscreen;
+  if (pixbuf == NULL)
+    goto out;
 
-          monitor->texture = meta_create_texture (monitor_area.width, monitor_area.height,
-                                                  COGL_TEXTURE_COMPONENTS_RGBA,
-                                                  META_TEXTURE_FLAGS_NONE);
-          offscreen = cogl_offscreen_new_with_texture (monitor->texture);
-          monitor->fbo = COGL_FRAMEBUFFER (offscreen);
-        }
+  task_data = g_task_get_task_data (task);
 
-      if (!cogl_framebuffer_allocate (monitor->fbo, &catch_error))
-        {
-          /* Texture or framebuffer allocation failed; it's unclear why this happened;
-           * we'll try again the next time this is called. (MetaBackgroundActor
-           * caches the result, so user might be left without a background.)
-           */
-          cogl_object_unref (monitor->texture);
-          monitor->texture = NULL;
-          cogl_object_unref (monitor->fbo);
-          monitor->fbo = NULL;
+  width = gdk_pixbuf_get_width (pixbuf);
+  height = gdk_pixbuf_get_height (pixbuf);
+  row_stride = gdk_pixbuf_get_rowstride (pixbuf);
+  pixels = gdk_pixbuf_get_pixels (pixbuf);
+  has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
 
-          cogl_error_free (catch_error);
-          return NULL;
-        }
+  pixel_format = has_alpha ? COGL_PIXEL_FORMAT_RGBA_8888 : COGL_PIXEL_FORMAT_RGB_888;
 
-      cogl_framebuffer_orthographic (monitor->fbo, 0, 0,
-                                     monitor_area.width, monitor_area.height, -1., 1.);
+  texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, width, height,
+                                                         pixel_format,
+                                                         row_stride,
+                                                         pixels,
+                                                         NULL));
 
-      if (texture2 != NULL && priv->blend_factor != 0.0)
+  if (texture == NULL)
+    {
+      g_set_error_literal (error,
+                           COGL_BITMAP_ERROR,
+                           COGL_BITMAP_ERROR_FAILED,
+                           _("background texture could not be created from file"));
+      goto out;
+    }
+
+  ensure_pipeline (self);
+  unset_texture (self);
+  set_style (self, task_data->style);
+  set_filename (self, task_data->filename);
+  set_texture (self, texture);
+
+  clutter_content_invalidate (CLUTTER_CONTENT (self));
+  loaded = TRUE;
+
+out:
+  if (pixbuf != NULL)
+    g_object_unref (pixbuf);
+  return loaded;
+}
+
+/**
+ * meta_background_copy:
+ * @self: a #MetaBackground to copy
+ * @monitor: a monitor
+ * @effects: effects to use on copy of @self
+ *
+ * Creates a new #MetaBackground to draw the background for the given monitor.
+ * Background will be loaded from @self and will share state
+ * with @self, but may have different effects applied to it.
+ *
+ * Return value: (transfer full): the newly created background content
+ */
+MetaBackground *
+meta_background_copy (MetaBackground        *self,
+                      int                    monitor,
+                      MetaBackgroundEffects  effects)
+{
+  MetaBackground *background;
+
+  background = META_BACKGROUND (g_object_new (META_TYPE_BACKGROUND,
+                                              "meta-screen", self->priv->screen,
+                                              "monitor", monitor,
+                                              NULL));
+
+  background->priv->brightness = self->priv->brightness;
+
+  background->priv->shading_direction = self->priv->shading_direction;
+  background->priv->color = self->priv->color;
+  background->priv->second_color = self->priv->second_color;
+  background->priv->filename = g_strdup (self->priv->filename);
+
+  /* we can reuse the pipeline if it has no effects applied, or
+   * if it has the same effects applied
+   */
+  if (effects == self->priv->effects ||
+      self->priv->effects == META_BACKGROUND_EFFECTS_NONE)
+    {
+      ensure_pipeline (self);
+      background->priv->pipeline = cogl_pipeline_copy (self->priv->pipeline);
+      background->priv->texture = cogl_object_ref (self->priv->texture);
+      background->priv->style = self->priv->style;
+
+      if (effects != self->priv->effects)
         {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_REPLACE);
-          cogl_pipeline_set_color4f (pipeline,
-                                      priv->blend_factor, priv->blend_factor, priv->blend_factor, priv->blend_factor);
-          cogl_pipeline_set_layer_texture (pipeline, 0, texture2);
-          cogl_pipeline_set_layer_wrap_mode (pipeline, 0, get_wrap_mode (priv->style));
-
-          bare_region_visible = draw_texture (self,
-                                              monitor->fbo, pipeline,
-                                              texture2, &monitor_area);
+          set_effects (background, effects);
 
-          cogl_object_unref (pipeline);
+          if (effects & META_BACKGROUND_EFFECTS_VIGNETTE)
+            {
+              set_brightness (background, self->priv->brightness);
+              set_vignette_sharpness (background, self->priv->vignette_sharpness);
+            }
         }
       else
         {
-          cogl_framebuffer_clear4f (monitor->fbo,
-                                    COGL_BUFFER_BIT_COLOR,
-                                    0.0, 0.0, 0.0, 0.0);
+          background->priv->effects = self->priv->effects;
         }
 
-      if (texture1 != NULL && priv->blend_factor != 1.0)
-        {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_ADD);
-          cogl_pipeline_set_color4f (pipeline,
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor),
-                                     (1 - priv->blend_factor));;
-          cogl_pipeline_set_layer_texture (pipeline, 0, texture1);
-          cogl_pipeline_set_layer_wrap_mode (pipeline, 0, get_wrap_mode (priv->style));
-
-          bare_region_visible = bare_region_visible || draw_texture (self,
-                                                                     monitor->fbo, pipeline,
-                                                                     texture1, &monitor_area);
-
-          cogl_object_unref (pipeline);
-        }
+    }
+  else
+    {
+      ensure_pipeline (background);
+      if (self->priv->texture != NULL)
+        set_texture (background, cogl_object_ref (self->priv->texture));
+      set_style (background, self->priv->style);
+      set_effects (background, effects);
 
-      if (bare_region_visible)
+      if (effects & META_BACKGROUND_EFFECTS_VIGNETTE)
         {
-          CoglPipeline *pipeline = create_pipeline (PIPELINE_OVER_REVERSE);
-
-          ensure_color_texture (self);
-          cogl_pipeline_set_layer_texture (pipeline, 0, priv->color_texture);
-          cogl_framebuffer_draw_rectangle (monitor->fbo,
-                                           pipeline,
-                                           0, 0,
-                                           monitor_area.width, monitor_area.height);
-          cogl_object_unref (pipeline);
+          set_brightness (background, self->priv->brightness);
+          set_vignette_sharpness (background, self->priv->vignette_sharpness);
         }
-
-      monitor->dirty = FALSE;
     }
 
-  if (texture_area)
-    set_texture_area_from_monitor_area (&monitor_area, texture_area);
+  clutter_content_invalidate (CLUTTER_CONTENT (background));
 
-  if (wrap_mode)
-    *wrap_mode = COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
-  return monitor->texture;
+  return background;
 }
-
+/**
+ * meta_background_new:
+ * @screen: the #MetaScreen
+ * @monitor: a monitor in @screen
+ * @effects: which effect flags to enable
+ *
+ * Creates a new #MetaBackground to draw the background for the given monitor.
+ * The returned object should be set on a #MetaBackgroundActor with
+ * clutter_actor_set_content().
+ *
+ * The background may be given a vignette by setting @effects
+ *
+ * Return value: the newly created background content
+ */
 MetaBackground *
-meta_background_new  (MetaScreen *screen)
+meta_background_new (MetaScreen            *screen,
+                     int                    monitor,
+                     MetaBackgroundEffects  effects)
+{
+  MetaBackground *background;
+
+  background = META_BACKGROUND (g_object_new (META_TYPE_BACKGROUND,
+                                              "meta-screen", screen,
+                                              "monitor", monitor,
+                                              "effects", effects,
+                                              NULL));
+  return background;
+}
+
+/**
+ * meta_background_get_style:
+ * @self: a #MetaBackground
+ *
+ * Returns the current background style.
+ *
+ * Return value: a #GDesktopBackgroundStyle
+ */
+GDesktopBackgroundStyle
+meta_background_get_style (MetaBackground *self)
 {
-  return g_object_new (META_TYPE_BACKGROUND,
-                       "meta-screen", screen,
-                       NULL);
+    return self->priv->style;
 }
 
-void
-meta_background_set_color (MetaBackground *self,
-                           ClutterColor   *color)
+/**
+ * meta_background_get_shading:
+ * @self: a #MetaBackground
+ *
+ * Returns whether @self is a solid color,
+ * vertical gradient, horizontal gradient,
+ * or none of the above.
+ *
+ * Return value: a #GDesktopBackgroundShading
+ */
+GDesktopBackgroundShading
+meta_background_get_shading (MetaBackground *self)
 {
-  ClutterColor dummy = { 0 };
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (color != NULL);
-
-  meta_background_set_gradient (self,
-                                G_DESKTOP_BACKGROUND_SHADING_SOLID,
-                                color, &dummy);
-}
-
-void
-meta_background_set_gradient (MetaBackground            *self,
-                              GDesktopBackgroundShading  shading_direction,
-                              ClutterColor              *color,
-                              ClutterColor              *second_color)
-{
-  MetaBackgroundPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (color != NULL);
-  g_return_if_fail (second_color != NULL);
-
-  priv = self->priv;
-
-  priv->shading_direction = shading_direction;
-  priv->color = *color;
-  priv->second_color = *second_color;
-
-  free_color_texture (self);
-  free_wallpaper_texture (self);
-  mark_changed (self);
+    return self->priv->shading_direction;
 }
 
-void
-meta_background_set_file (MetaBackground            *self,
-                          GFile                     *file,
-                          GDesktopBackgroundStyle    style)
+/**
+ * meta_background_get_color:
+ * @self: a #MetaBackground
+ *
+ * Returns the first color of @self. If self
+ * is a gradient, the second color can be returned
+ * with meta_background_get_second_color().
+ *
+ * Return value: (transfer none): a #ClutterColor
+ */
+const ClutterColor *
+meta_background_get_color (MetaBackground *self)
 {
-  g_return_if_fail (META_IS_BACKGROUND (self));
-
-  meta_background_set_blend (self, file, NULL, 0.0, style);
+    return &self->priv->color;
 }
 
-void
-meta_background_set_blend (MetaBackground          *self,
-                           GFile                   *file1,
-                           GFile                   *file2,
-                           double                   blend_factor,
-                           GDesktopBackgroundStyle  style)
+/**
+ * meta_background_get_second_color:
+ * @self: a #MetaBackground
+ *
+ * Returns the second color of @self. If @self
+ * is not a gradient this function is undefined.
+ *
+ * Return value: (transfer none): a #ClutterColor
+ */
+const ClutterColor *
+meta_background_get_second_color (MetaBackground *self)
 {
-  MetaBackgroundPrivate *priv;
-
-  g_return_if_fail (META_IS_BACKGROUND (self));
-  g_return_if_fail (blend_factor >= 0.0 && blend_factor <= 1.0);
-
-  priv = self->priv;
-
-  set_file (self, &priv->file1, &priv->background_image1, file1);
-  set_file (self, &priv->file2, &priv->background_image2, file2);
-
-  priv->blend_factor = blend_factor;
-  priv->style = style;
-
-  free_wallpaper_texture (self);
-  mark_changed (self);
+    return &self->priv->second_color;
 }
 
-void
-meta_background_refresh_all (void)
+/**
+ * meta_background_get_filename:
+ * @self: a #MetaBackground
+ *
+ * Returns the filename of the currently loaded file.
+ * IF @self is not loaded from a file this function is
+ * undefined.
+ *
+ * Return value: (transfer none): the filename
+ */
+const char *
+meta_background_get_filename (MetaBackground *self)
 {
-  GSList *l;
-
-  for (l = all_backgrounds; l; l = l->next)
-    mark_changed (l->data);
+    return self->priv->filename;
 }
diff '--exclude=.git' -urN a/src/compositor/plugins/default.c b/src/compositor/plugins/default.c
--- a/src/compositor/plugins/default.c	2016-08-29 18:17:55.000000000 -0400
+++ b/src/compositor/plugins/default.c	2016-09-27 23:36:24.770641091 -0400
@@ -331,16 +331,15 @@
   for (i = 0; i < n; i++)
     {
       MetaRectangle rect;
-      ClutterActor *background_actor;
-      MetaBackground *background;
+      ClutterActor *background;
       ClutterColor color;
 
       meta_screen_get_monitor_geometry (screen, i, &rect);
 
-      background_actor = meta_background_actor_new (screen, i);
+      background = meta_background_actor_new ();
 
-      clutter_actor_set_position (background_actor, rect.x, rect.y);
-      clutter_actor_set_size (background_actor, rect.width, rect.height);
+      clutter_actor_set_position (background, rect.x, rect.y);
+      clutter_actor_set_size (background, rect.width, rect.height);
 
       /* Don't use rand() here, mesa calls srand() internally when
          parsing the driconf XML, but it's nice if the colors are
@@ -351,18 +350,9 @@
                           g_rand_int_range (rand, 0, 255),
                           g_rand_int_range (rand, 0, 255),
                           255);
+      clutter_actor_set_background_color (background, &color);
 
-      background = meta_background_new (screen);
-      meta_background_set_color (background, &color);
-      meta_background_actor_set_background (META_BACKGROUND_ACTOR (background_actor), background);
-      g_object_unref (background);
-
-      meta_background_actor_set_vignette (META_BACKGROUND_ACTOR (background_actor),
-                                          TRUE,
-                                          0.5,
-                                          0.5);
-
-      clutter_actor_add_child (self->priv->background_group, background_actor);
+      clutter_actor_add_child (self->priv->background_group, background);
     }
 
   g_rand_free (rand);
diff '--exclude=.git' -urN a/src/meta/meta-background-actor.h b/src/meta/meta-background-actor.h
--- a/src/meta/meta-background-actor.h	2016-07-29 00:51:37.000000000 -0400
+++ b/src/meta/meta-background-actor.h	2016-09-27 23:33:00.710842990 -0400
@@ -22,8 +22,9 @@
 #define META_BACKGROUND_ACTOR_H
 
 #include <clutter/clutter.h>
+#include <cogl/cogl.h>
+
 #include <meta/screen.h>
-#include <meta/meta-background.h>
 
 #include <gsettings-desktop-schemas/gdesktop-enums.h>
 
@@ -61,15 +62,6 @@
 
 GType meta_background_actor_get_type (void);
 
-ClutterActor *meta_background_actor_new    (MetaScreen *screen,
-                                            int         monitor);
-
-void meta_background_actor_set_background  (MetaBackgroundActor *self,
-                                            MetaBackground      *background);
-
-void meta_background_actor_set_vignette (MetaBackgroundActor *self,
-                                         gboolean             enabled,
-                                         double               brightness,
-                                         double               sharpness);
+ClutterActor *meta_background_actor_new (void);
 
 #endif /* META_BACKGROUND_ACTOR_H */
diff '--exclude=.git' -urN a/src/meta/meta-background-image.h b/src/meta/meta-background-image.h
--- a/src/meta/meta-background-image.h	2016-07-29 00:51:38.000000000 -0400
+++ b/src/meta/meta-background-image.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,76 +0,0 @@
-/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
-/*
- * MetaBackgroundImageCache:
- *
- * Simple cache for background textures loaded from files
- *
- * Copyright 2014 Red Hat, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef __META_BACKGROUND_IMAGE_H__
-#define __META_BACKGROUND_IMAGE_H__
-
-#include <glib-object.h>
-#include <cogl/cogl.h>
-
-#define META_TYPE_BACKGROUND_IMAGE            (meta_background_image_get_type ())
-#define META_BACKGROUND_IMAGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImage))
-#define META_BACKGROUND_IMAGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImageClass))
-#define META_IS_BACKGROUND_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_BACKGROUND_IMAGE))
-#define META_IS_BACKGROUND_IMAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_BACKGROUND_IMAGE))
-#define META_BACKGROUND_IMAGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_BACKGROUND_IMAGE, MetaBackgroundImageClass))
-
-/**
- * MetaBackgroundImage:
- *
- * #MetaBackgroundImage is an object that represents a loaded or loading background image.
- */
-typedef struct _MetaBackgroundImage      MetaBackgroundImage;
-typedef struct _MetaBackgroundImageClass MetaBackgroundImageClass;
-
-GType meta_background_image_get_type (void);
-
-gboolean     meta_background_image_is_loaded   (MetaBackgroundImage *image);
-gboolean     meta_background_image_get_success (MetaBackgroundImage *image);
-CoglTexture *meta_background_image_get_texture (MetaBackgroundImage *image);
-
-#define META_TYPE_BACKGROUND_IMAGE_CACHE            (meta_background_image_cache_get_type ())
-#define META_BACKGROUND_IMAGE_CACHE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCache))
-#define META_BACKGROUND_IMAGE_CACHE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCacheClass))
-#define META_IS_BACKGROUND_IMAGE_CACHE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_BACKGROUND_IMAGE_CACHE))
-#define META_IS_BACKGROUND_IMAGE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_BACKGROUND_IMAGE_CACHE))
-#define META_BACKGROUND_IMAGE_CACHE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_BACKGROUND_IMAGE_CACHE, MetaBackgroundImageCacheClass))
-
-/**
- * MetaBackgroundImageCache:
- *
- * #MetaBackgroundImageCache caches loading of textures for backgrounds; there's actually
- * nothing background specific about it, other than it is tuned to work well for
- * large images as typically are used for backgrounds.
- */
-typedef struct _MetaBackgroundImageCache      MetaBackgroundImageCache;
-typedef struct _MetaBackgroundImageCacheClass MetaBackgroundImageCacheClass;
-
-MetaBackgroundImageCache *meta_background_image_cache_get_default (void);
-
-GType meta_background_image_cache_get_type (void);
-
-MetaBackgroundImage *meta_background_image_cache_load  (MetaBackgroundImageCache *cache,
-                                                        GFile                    *file);
-void                 meta_background_image_cache_purge (MetaBackgroundImageCache *cache,
-                                                        GFile                    *file);
-
-#endif /* __META_BACKGROUND_IMAGE_H__ */
diff '--exclude=.git' -urN a/src/meta/meta-background.h b/src/meta/meta-background.h
--- a/src/meta/meta-background.h	2016-07-29 00:51:37.000000000 -0400
+++ b/src/meta/meta-background.h	2016-09-27 23:33:00.710842990 -0400
@@ -1,8 +1,8 @@
 /* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
 /*
- * meta-background-actor.h:  for painting the root window background
+ * meta-background.h: CoglTexture for paintnig the system background
  *
- * Copyright 2010 Red Hat, Inc.
+ * Copyright 2013 Red Hat, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -21,16 +21,19 @@
 #ifndef META_BACKGROUND_H
 #define META_BACKGROUND_H
 
+#include <cogl/cogl.h>
 #include <clutter/clutter.h>
-#include <gsettings-desktop-schemas/gdesktop-enums.h>
+
 #include <meta/screen.h>
 
+#include <gsettings-desktop-schemas/gdesktop-enums.h>
+
 /**
  * MetaBackground:
  *
- * This class handles tracking and painting the root window background.
- * By integrating with #MetaWindowGroup we can avoid painting parts of
- * the background that are obscured by other windows.
+ * This class handles loading a background from file, screenshot, or
+ * color scheme. The resulting object can be associated with one or
+ * more #MetaBackgroundActor objects to handle loading the background.
  */
 
 #define META_TYPE_BACKGROUND            (meta_background_get_type ())
@@ -44,6 +47,20 @@
 typedef struct _MetaBackgroundClass   MetaBackgroundClass;
 typedef struct _MetaBackgroundPrivate MetaBackgroundPrivate;
 
+/**
+ * MetaBackgroundEffects:
+ * @META_BACKGROUND_EFFECTS_NONE: No effect
+ * @META_BACKGROUND_EFFECTS_VIGNETTE: Vignette
+ *
+ * Which effects to enable on the background
+ */
+
+typedef enum
+{
+  META_BACKGROUND_EFFECTS_NONE       = 0,
+  META_BACKGROUND_EFFECTS_VIGNETTE   = 1 << 1,
+} MetaBackgroundEffects;
+
 struct _MetaBackgroundClass
 {
   /*< private >*/
@@ -52,30 +69,41 @@
 
 struct _MetaBackground
 {
+  /*< private >*/
   GObject parent;
 
   MetaBackgroundPrivate *priv;
 };
 
-void meta_background_refresh_all (void);
-
 GType meta_background_get_type (void);
 
-MetaBackground *meta_background_new  (MetaScreen *screen);
-
-void meta_background_set_color    (MetaBackground            *self,
-                                   ClutterColor              *color);
-void meta_background_set_gradient (MetaBackground            *self,
-                                   GDesktopBackgroundShading  shading_direction,
-                                   ClutterColor              *color,
-                                   ClutterColor              *second_color);
-void meta_background_set_file     (MetaBackground            *self,
-                                   GFile                     *file,
-                                   GDesktopBackgroundStyle    style);
-void meta_background_set_blend    (MetaBackground            *self,
-                                   GFile                     *file1,
-                                   GFile                     *file2,
-                                   double                     blend_factor,
-                                   GDesktopBackgroundStyle    style);
+MetaBackground *meta_background_new (MetaScreen           *screen,
+                                     int                   monitor,
+				     MetaBackgroundEffects effects);
+MetaBackground *meta_background_copy (MetaBackground        *self,
+                                      int                    monitor,
+				      MetaBackgroundEffects  effects);
+
+void meta_background_load_gradient (MetaBackground            *self,
+                                    GDesktopBackgroundShading  shading_direction,
+                                    ClutterColor              *color,
+                                    ClutterColor              *second_color);
+void meta_background_load_color (MetaBackground *self,
+                                 ClutterColor   *color);
+void meta_background_load_file_async (MetaBackground          *self,
+                                      const char              *filename,
+                                      GDesktopBackgroundStyle  style,
+                                      GCancellable            *cancellable,
+                                      GAsyncReadyCallback      callback,
+                                      gpointer                 user_data);
+gboolean meta_background_load_file_finish (MetaBackground       *self,
+                                           GAsyncResult         *result,
+                                           GError              **error);
+
+const char *meta_background_get_filename (MetaBackground *self);
+GDesktopBackgroundStyle meta_background_get_style (MetaBackground *self);
+GDesktopBackgroundShading meta_background_get_shading (MetaBackground *self);
+const ClutterColor *meta_background_get_color (MetaBackground *self);
+const ClutterColor *meta_background_get_second_color (MetaBackground *self);
 
 #endif /* META_BACKGROUND_H */
